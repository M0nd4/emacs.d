#+AUTHOR: Jeremy Bi
#+TITLE: My Emacs Configuration

* Emacs Org Configuration

This file is tangled using =org-babel-load-file=. What this does is
generate a =emacs-init.el= from the =emacs-lisp= source blocks.

This emacs.d is currently  designed for Emacs 24.3 and above.

*** Credits:

This emacs.d was heavily inspired by the following configurations.

[[https://github.com/daschwa/dotfiles/tree/master/emacs.d][Adam Schwartz's emacs.d]]

[[https://github.com/bbatsov/prelude][Bozhidar Batsov's prelude]]

[[https://github.com/larstvei/dot-emacs][larstvei's dot-emacs]]

* Package Management

[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs.  It
utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], to update a
centralized =Cask= file when you install or remove packages.

** Cask

Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle no
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

** Pallet

You can download all packages in your =Cask= file by using =M-x
pallet-install=. However, this should not be necessary.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'pallet)
#+END_SRC

* Packages, Modes, and Extensions

** Dependency Management with =req-package=

Where Pallet keeps track of the packages we have installed,
=req-package= handles all our internal package dependencies and
configurations.

Another nice thing about =req-package=, is that you no longer not need
to specify the =:ensure= keyword, as it is added by default.

Start using =req-package=
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Add the personal packages directory to the load-path
  (add-to-list 'load-path (concat user-emacs-directory "packages/"))
  (require 'req-package)
#+END_SRC
* Meta

We add a function to the =after-save-hook= ensuring to always tangle
and byte-compile the =org=-document after changes.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my-init-hook ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (let ((my-org-file (expand-file-name (concat user-emacs-directory "emacs-init.org"))))
      (when (equal (buffer-file-name) my-org-file)
        (org-babel-tangle)
        (byte-compile-file my-init-file))))
  (add-hook 'after-save-hook 'my-init-hook)
#+END_SRC

* Essentials

Some quick essential customizations.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Turn off mouse interface early in startup to avoid momentary display
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

  (unless (file-exists-p savefile-dir)
    (make-directory savefile-dir))

  ;; Load elisp bits collected from everywhere
  (require 'elisp)

  ;; Start off with some sanity.
  (require 'better-defaults)

  ;; OSX specific settings
  (when (eq system-type 'darwin)
    (require 'cocoa-emacs-default))

  ;; No splash screen please
  (setq inhibit-startup-screen t)

  ;; Store all backup and autosave files in the tmp dir
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))

  ;; saveplace remembers your location in a file when saving files
  (require 'saveplace)
  (setq save-place-file (expand-file-name "saveplace" savefile-dir))
  ;; activate it for all buffers
  (setq-default save-place t)

  ;; savehist keeps track of some history
  (require 'savehist)
  (setq savehist-additional-variables
        ;; search entries
        '(search ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-file (expand-file-name "savehist" savefile-dir))
  (savehist-mode +1)

  ;; save recent files
  (require 'recentf)
  (setq recentf-save-file (expand-file-name "recentf" savefile-dir)
        recentf-max-saved-items 500
        recentf-max-menu-items 15)

  ;; reduce the frequency of garbage collection by making it happen on
  (setq gc-cons-threshold (* 1024 1024 20))

  ;; warn when opening files bigger than 100MB
  (setq large-file-warning-threshold 100000000)

  ;; autopair
  ;; (electric-pair-mode)

  ;; enable narrowing commands
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)

  ;; enabled change region case commands
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

  ;; enable erase-buffer command
  (put 'erase-buffer 'disabled nil)
#+END_SRC

* Appearance

** Theme

Set custom theme path and load theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force zenburn-theme
    :config
    (load-theme 'zenburn t))
#+END_SRC

** Mode Line

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force smart-mode-line
    :init
    (setq sml/no-confirm-load-theme t)
    :config
    (sml/setup))
#+END_SRC

* Keybindings

** Improvements
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; convenient line number showing
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  ;; From better defaults
  (bind-key "M-/" 'hippie-expand)
  (bind-key "C-x C-b" 'ibuffer)
  (bind-key "C-:" 'eval-expression)
  (bind-key "M-SPC" 'cycle-spacing)
  ;; (bind-key "C-c x" 'sunrise-cd)
  ;; (bind-key "C-c X" 'sunrise)
  (bind-key "C-c q" 'auto-fill-mode)
  (bind-key "M-'" 'next-error)
  (bind-key "C-c k" 'prelude-kill-other-buffers)
  (bind-key "C-c n" 'prelude-cleanup-buffer-or-region)
  (bind-key "C-c M-d" 'prelude-duplicate-and-comment-current-line-or-region)
  (bind-key "C-c d" 'prelude-duplicate-current-line-or-region)
  (bind-key [(control shift return)] 'prelude-smart-open-line-above)
  (bind-key "C-M-h" 'backward-kill-word)
  ;; (bind-key "C-x [" 'shrink-window)
  ;; (bind-key "C-x ]" 'enlarge-window)

  ;; Set Regexp Alignment
  (bind-key "C-x \\" 'align-regexp)

  ;; Font size
  (bind-key "C-+" 'text-scale-increase)
  (bind-key "C--" 'text-scale-decrease)

  ;; Indentation help
  (bind-key "C-^" 'prelude-top-join-line)

  ;; A complementary binding to the apropos-command (C-h a)
  (define-key 'help-command "A" 'apropos)

  (bind-key "C-f" 'find-function 'help-command)
  (bind-key "C-k" 'find-function-on-key 'help-command)
  (bind-key "C-v" 'find-variable 'help-command)
  (bind-key "C-l" 'find-library 'help-command)

  (global-set-key [remap kill-whole-line] 'prelude-kill-whole-line)
  (global-set-key [remap move-beginning-of-line]
                  'prelude-move-beginning-of-line)

#+END_SRC

** Key-chord

Key-chord maps pairs of simultaneously pressed keys to commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force key-chord
    :config
    (key-chord-mode +1)
    (setq key-chord-two-keys-delay 0.05)
    (key-chord-define-global "jl" 'prelude-switch-to-previous-buffer)
    (key-chord-define-global "x1" 'delete-other-windows)
    (key-chord-define-global "xk" 'ace-window)
    (key-chord-define-global "0o" 'delete-window)
    (key-chord-define-global "xn" 'helm-mini)
    (key-chord-define-global "jk" 'magit-status)
    (key-chord-define-global "xm" 'helm-M-x))
#+END_SRC

** Unbind keys

#+BEGIN_SRC emacs-lisp :tangle yes
  (unbind-key "C-o")
  (unbind-key "C-x f")
#+END_SRC

* Setups

All packages and modes are configured here.
** Major Modes
*** Magit

[[https://github.com/magit/magit][Magit]] is the ultimate =git= interface for Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force magit
    :diminish (magit-auto-revert-mode . ""))
#+END_SRC

*** Monky

[[https://github.com/ananthakumaran/monky][Monky]] provides an interactive interface for Hg.

#+begin_src emacs-lisp :tangle yes
  (req-package monky
    :bind ("C-x g" . monky-status)
    :config
    (setq monky-process-type 'cmdserver))
#+end_src

*** Lisp

**** Clojure

#+begin_src emacs-lisp :tangle yes
  (req-package clojure-mode
    :config
    (defun prelude-clojure-mode-defaults ()
      (subword-mode +1))
    (add-hook 'clojure-mode-hook 'prelude-clojure-mode-defaults))
#+end_src

**** Emacs lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (add-hook 'after-save-hook
              (lambda ()
                (when (file-exists-p (byte-compile-dest-file buffer-file-name))
                  (emacs-lisp-byte-compile)))
              nil
              t))

  (defun prelude-conditional-emacs-lisp-checker ()
    "Don't check doc style in Emacs Lisp test files."
    (let ((file-name (buffer-file-name)))
      (when (and file-name (string-match-p ".*-tests?\\.el\\'" file-name))
        (setq-local flycheck-checkers '(emacs-lisp)))))

  (defun prelude-emacs-lisp-mode-defaults ()
    "Sensible defaults for `emacs-lisp-mode'."
    (eldoc-mode +1)
    (diminish 'eldoc-mode "")
    (prelude-recompile-elc-on-save)
    (setq mode-name "EL")
    (prettify-symbols-mode +1)
    (add-hook 'eval-expression-minibuffer-setup-hook 'eldoc-mode)
    (prelude-conditional-emacs-lisp-checker))

  (add-hook 'emacs-lisp-mode-hook 'prelude-emacs-lisp-mode-defaults)

  ;; ielm is an interactive Emacs Lisp shell
  (defun prelude-ielm-mode-defaults ()
    "Sensible defaults for `ielm'."
    (whitespace-mode -1)
    (eldoc-mode +1))

  (add-hook 'ielm-mode-hook 'prelude-ielm-mode-defaults)

  (add-to-list 'auto-mode-alist '("Cask\\'" . emacs-lisp-mode))

  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
  (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)

#+END_SRC

*** Geiser/Scheme

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force geiser
    :config
    (setq geiser-active-implementations '(racket)))

  (add-hook 'scheme-mode-hook
            (lambda ()
              (push '("lambda" . 955) prettify-symbols-alist)))
#+END_SRC

*** LaTex

Sane setup for LaTeX writers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package tex-site
    :require latex-extra
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)

    (setq-default TeX-master nil)

    ;; use pdflatex
    (TeX-global-PDF-mode 1)

    ;; sensible defaults for OS X, other OSes should be covered out-of-the-box
    (when (eq system-type 'darwin)
      (setq TeX-view-program-selection
            '((output-dvi "DVI Viewer")
              (output-pdf "PDF Viewer")
              (output-html "HTML Viewer")))

      (setq TeX-view-program-list
            '(("DVI Viewer" "open %o")
              ("PDF Viewer" "open %o")
              ("HTML Viewer" "open %o"))))

    (defun prelude-latex-mode-defaults ()
      (turn-on-auto-fill)
      (add-to-list 'TeX-engine-alist-builtin
                   '(xetex "XeTeX" "xetex -shell-escape" "xelatex -shell-escape" "xetex"))
      (latex/setup-keybinds)
      (abbrev-mode +1))

    (add-hook 'LaTeX-mode-hook 'prelude-latex-mode-defaults))

#+END_SRC

*** Org Mode

If you are not using it, you need to start.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force org
    :config
    (require 'ox-md)
    (require 'ox-latex)

    (defun org-mode-defaults ()
      (turn-on-org-cdlatex)
      (diminish 'org-cdlatex-mode "")
      (turn-on-auto-fill)
      (bind-key "C-c b" 'ebib-insert-bibtex-key org-mode-map))

    (add-hook 'org-mode-hook 'org-mode-defaults)

    ;; Fontify org-mode code blocks
    (setq org-src-fontify-natively t)

    (setq org-todo-keyword-faces
          '(("TODO" . (:foreground "green" :weight bold))
            ("NEXT" :foreground "blue" :weight bold)
            ("WAITING" :foreground "orange" :weight bold)
            ("HOLD" :foreground "magenta" :weight bold)
            ("CANCELLED" :foreground "forest green" :weight bold)))

    (setq org-enforce-todo-dependencies t)
    (setq org-src-tab-acts-natively t)
    (setq org-src-window-setup 'current-window)

    ;; set up latex
    (setq org-latex-create-formula-image-program 'imagemagick)

    (setq org-latex-pdf-process
          (quote ("pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                  "bibtex $(basename %b)"
                  "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                  "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f")))

    ;; Tell the latex export to use the minted package for source
    ;; code coloration.
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (setq org-latex-listings 'minted)

    (setq org-latex-minted-options
          '(("frame" "lines") ("framesep" "6pt")
            ("mathescape" "true") ("fontsize" "\\small")))

    ;; execute external programs.
    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (dot . t)
             (ditaa . t)
             (R . t)
             (python . t)
             (ruby . t)
             (gnuplot . t)
             (clojure . t)
             (sh . t)
             (haskell . t)
             (octave . t)
             (org . t)
             (plantuml . t)
             (scala . t)
             (sql . t)
             (latex . t))))

    (setq org-confirm-babel-evaluate nil))
#+END_SRC

[[https://github.com/jkitchin/jmax/blob/master/org-ref.org][Org-ref]] is an emacs-lisp module to handle bibliographic citations, and
references to figures, tables and sections in org-mode.

#+begin_src emacs-lisp :tangle yes
  (eval-after-load "org"
    '(progn
      (org-require 'org-ref)
      (setq org-ref-default-bibliography '("/Users/jeremybi/research/refs.bib")
            org-ref-pdf-directory "/Users/jeremybi/research/papers/"
            org-ref-bibliography-notes "/Users/jeremybi/research/notes.org")))
#+end_src

*** Dired and dired+

Dired Plus is an extension to the =dired= file manager in Emacs.  My
favorite feature is that pressing =F= will open all marked files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package dired
    :commands dired-jump
    :config
    (put 'dired-find-alternate-file 'disabled nil)

    ;; always delete and copy recursively
    (setq dired-recursive-deletes 'always)
    (setq dired-recursive-copies 'always)
    ;; show readable size
    (setq dired-listing-switches "-alh")

    (setq dired-dwim-target t)

    ;; enable some really cool extensions like C-x C-j(dired-jump)
    (require 'dired-x)

    (setq-default dired-omit-mode t
                  dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\."))

  (req-package dired+)
#+END_SRC

*** Scala-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package scala-mode2
    :config
    (setq scala-indent:align-forms t
          scala-indent:align-parameters t)
    (defun scala-mode-hook-defaults ()
      (company-mode -1)
      (subword-mode +1))
    (add-hook 'scala-mode-hook 'scala-mode-hook-defaults))
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC

*** Eshell

Type =clear= to clear the buffer like in other terminal emulators.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (setq eshell-directory-name
        (expand-file-name "eshell" savefile-dir))

  (defun eshell/clear ()
    "Clears the shell buffer ala Unix's clear."
    ;; the shell prompts are read-only, so clear that for the duration
    (let ((inhibit-read-only t))
      ;; simply delete the region
      (erase-buffer)))
#+END_SRC

*** Haskell Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package haskell-mode
    :config
    (defun prelude-haskell-mode-defaults ()
      (subword-mode +1)
      (turn-on-haskell-doc-mode))
    (add-hook 'haskell-mode-hook
              'prelude-haskell-mode-defaults)
    (setq haskell-tags-on-save t
          haskell-process-suggest-hoogle-imports t
          haskell-process-suggest-remove-import-lines t
          haskell-process-auto-import-loaded-modules t
          haskell-process-type 'cabal-repl
          haskell-process-log t)
    ;; Haskell-mode bindings
    (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
    (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
    (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
    (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
    (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
    (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
    (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal)
    (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)
    (define-key haskell-mode-map (kbd "M-.") 'haskell-mode-jump-to-def-or-tag)

    ;; Cabal-mode bindings
    (eval-after-load 'haskell-cabal
      '(progn
         (define-key haskell-cabal-mode-map (kbd "C-`") 'haskell-interactive-bring)
         (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
         (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
         (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal))))
#+END_SRC

*** SML Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package sml-mode
    :mode "\\.sml\\'"
    :config
    (defun my-sml-prog-proc-send-buffer ()
      "If sml repl exists, then restart it else create a new repl."
      (interactive)
      (when (get-buffer "*sml*")
        (with-current-buffer "*sml*"
          (when (get-process "sml")
            (comint-send-eof)))
        (sleep-for 0.2)
        (sml-run "sml" ""))
      (sml-prog-proc-send-buffer t))
    (bind-key "C-c C-b" 'my-sml-prog-proc-send-buffer sml-mode-map))

#+END_SRC

*** Js2 Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package js2-mode
    :mode "\\.js\\'")
#+END_SRC

** Minor Modes
*** Ido-related

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-force ido-ubiquitous
    :config
    (ido-ubiquitous-mode +1))

  (req-package-force flx-ido
    :config
    (flx-ido-mode +1))

  (req-package-force ido-vertical-mode
    :config
    (ido-vertical-mode +1))
#+END_SRC

*** Wgrep

[[https://github.com/mhayashi1120/Emacs-wgrep][Wgrep]] allows you to edit a grep buffer and apply those changes to the
file buffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package wgrep-ag
    :require wgrep)
#+END_SRC

*** Helm

=helm-mini= is a part of [[https://github.com/emacs-helm/helm][Helm]] that shows current buffers and a list of
recent files using =recentf=.  It is a great way to manage many open
files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm
    :bind (("C-x C-f" . helm-find-files)
           ("M-y" . helm-show-kill-ring))
    :init
    (require 'helm-config)
    :config
    (setq helm-quick-update t
          helm-ff-search-library-in-sexp t
          helm-ff-file-name-history-use-recentf t
          helm-buffers-fuzzy-matching t
          helm-boring-file-regexp-list
          '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "\\.i$"))
    ;;; Save current position to mark ring
    (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
    (helm-mode 1))
#+END_SRC

*** Helm-swoop

[[https://github.com/ShingoFukuyama/helm-swoop][Helm-swoop]], efficiently hopping squeezed lines powered by Emacs
helm interface.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-swoop
    :require helm
    :bind (("M-i" . helm-swoop)
           ("M-I" . helm-swoop-back-to-last-point)
           ("C-c M-i" . helm-multi-swoop)
           ("C-x M-i" . helm-multi-swoop-all))
    :config
    ;; When doing isearch, hand the word over to helm-swoop
    (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
    ;; From helm-swoop to helm-multi-swoop-all
    (bind-key "M-i" 'helm-multi-swoop-all-from-helm-swoop helm-swoop-map))
#+END_SRC

*** Helm-descbinds

[[https://github.com/emacs-helm/helm-descbinds][Helm Descbinds]] provides an interface to emacs' =describe-bindings=
making the currently active key bindings interactively searchable
with helm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-descbinds
    :require helm
    :config
    (helm-descbinds-mode 1))
#+END_SRC

*** Fullframe

[[https://github.com/tomterl/fullframe][Fullframe]] advises commands to execute fullscreen, restoring the window
setup when exiting.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package fullframe
    :config
    (fullframe magit-status magit-mode-quit-window)
    (fullframe monky-status monky-quit-window)
    (fullframe info Info-exit)
    (fullframe ibuffer ibuffer-quit))
#+END_SRC

*** Mykie

[[https://github.com/yuutayamada/mykie-el][Mykie]] is a command multiplexer, which can add other functions to a
single keybind.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package mykie
    :config
    (setq mykie:use-major-mode-key-override 'global)
    (mykie:initialize)
    (mykie:set-keys nil
      "C-e"
      :default (move-end-of-line 1)
      :repeat  (end-of-buffer)
      :C-u (beginning-of-buffer)
      "C-S-n"
      :default (next-line 4)
      "C-S-p"
      :default (previous-line 4)
      "C-w"
      :default (kill-region (mark) (point))
      :minibuff (backward-kill-word 1)))
#+END_SRC

*** Ace-jump-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ace-jump-mode
    :bind ("C-c SPC" . ace-jump-mode)
    :config
    (setq ace-jump-mode-move-keys
        '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?z ?x ?c ?v ?b ?n ?m)))
#+END_SRC

*** Alert

[[https://github.com/jwiegley/alert][Alert]] is a Growl-workalike for Emacs which uses a common notification
interface.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package alert
    :config
    (setq terminal-notifier-command (executable-find "terminal-notifier"))
    (alert-define-style 'timed-notification :title "Notify using terminal-notifier"
                        :notifier
                        (lambda (info)
                          (if terminal-notifier-command
                              (let ((args
                                     (list "-title" (alert-encode-string (plist-get info :title))
                                           "-message" (alert-encode-string (plist-get info :message))
                                           "-sound" "default"
                                           "-sender" "org.gnu.Emacs")))
                                (apply #'call-process terminal-notifier-command nil nil nil args))
                            (alert-message-notify info))))
    (setq alert-default-style 'timed-notification)

    ;; To reminder me to stand up from long time coding
    (defvar my-timer-obj nil
      "For canceling if I cannot bear")

    (defun start-my-timer (arg)
      "Timer for long time coding."
      (interactive "p")
      (cl-case arg
        (4 (progn
             (cancel-timer my-timer-obj)
             (alert "Stop timing!" :title "Emacs")))
        (t (progn
             (if my-timer-obj (cancel-timer my-timer-obj))
             (setq my-timer-obj
                   (run-at-time "52 minutes" 2600
                                (lambda () (alert "Stand up, stretch out!" :title "Stop Watering"))))
             (alert "Start timing!" :title "Emacs")))))
    (bind-key* "C-c C-z" 'start-my-timer))

#+END_SRC

*** Ace-window

[[https://github.com/abo-abo/ace-window][Ace-window]] provides window switching, the visual way.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ace-window
    :require ace-jump-mode
    :bind ("C-x o" . ace-window)
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-scope 'frame))
#+END_SRC

*** Rainbow mode

=rainbow-mode= displays hexadecimal colors with the color they
represent as their background.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package rainbow-mode
    :diminish (rainbow-mode . "")
    :config
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

*** Rainbow-delimiter

[[https://github.com/jlr/rainbow-delimiters][Rainbow Delimiters]] is a “rainbow parentheses”-like mode which
highlights parentheses, brackets, and braces according to their depth

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** Elisp-slime-nav

[[https://github.com/purcell/elisp-slime-nav][Elisp-slime-nav]] allows very convenient navigation to the symbol at
point (using =M-.=), and the ability to pop back to previous marks
(using =M-,=).

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package elisp-slime-nav
    :diminish (elisp-slime-nav-mode . "")
    :config
    (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
      (add-hook hook 'elisp-slime-nav-mode)))
#+END_SRC

*** Operate-on-numbes

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package operate-on-number
    :require smartrep
    :config
    (setq smartrep-mode-line-active-bg nil)
    (smartrep-define-key global-map "C-c ."
      '(("+" . apply-operation-to-number-at-point)
        ("-" . apply-operation-to-number-at-point)
        ("*" . apply-operation-to-number-at-point)
        ("/" . apply-operation-to-number-at-point)
        ("^" . apply-operation-to-number-at-point)
        ("<" . apply-operation-to-number-at-point)
        (">" . apply-operation-to-number-at-point)
        ("'" . operate-on-number-at-point))))
#+END_SRC

*** Expand-region

[[https://github.com/magnars/expand-region.el][Expand-region]] increases the selected region by semantic units. Just
keep pressing the key until it selects what you want.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

*** Whitespace

Whitespace-mode configuration.

#+BEGIN_SRC emacs-lisp :tangle yes

  (req-package-force whitespace
    :diminish (whitespace-mode . "")
    :config
    (setq whitespace-line-column 80) ;; limit line length
    (setq whitespace-style '(face tabs trailing lines-tail))

    (defun prelude-enable-whitespace ()
      "Enable `whitespace-mode' if `prelude-whitespace' is not nil."
      (add-hook 'before-save-hook 'whitespace-cleanup nil t)
      (whitespace-mode +1))

    (add-hook 'text-mode-hook 'prelude-enable-whitespace)
    (add-hook 'prog-mode-hook 'prelude-enable-whitespace))

#+END_SRC

*** Ag

[[https://github.com/Wilfred/ag.el][Ag.el]] is a simple ag frontend, loosely based on ack-and-half.el.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ag
    :config
    (setq ag-highlight-search t))
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package projectile
    :diminish ""
    :bind (("s-p" . projectile-switch-project)
           ("s-d" . projectile-find-dir)
           ("s-f" . projectile-find-file)
           ("s-g" . projectile-ag))
    :init
    (projectile-global-mode)
    :config
    (setq projectile-cache-file
          (expand-file-name  "projectile.cache" savefile-dir))
    (setq projectile-sort-order 'modification-time))
#+END_SRC

*** Discover-my-major

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package discover-my-major
    :config
    (bind-key "C-m" 'discover-my-major 'help-command))
#+END_SRC

*** Perspective

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package perspective
    :config
    (setq persp-show-modestring 'header)
    (add-hook 'after-init-hook #'(lambda () (persp-mode 1)))
    (defun custom-persp-last ()
      (interactive)
      (persp-switch (persp-name persp-last)))
    ;; Easily switch to your last perspective
    (define-key persp-mode-map (kbd "C-x x '") 'custom-persp-last))
#+END_SRC

*** Persp-projectile

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package persp-projectile
    :require (projectile perspective)
    :bind ("s-s" . projectile-persp-switch-project))

#+END_SRC

*** Lispy

[[https://github.com/abo-abo/lispy][Lispy]] implements various vi-like commands for navigating and editing
Lisp code.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package lispy
    :require helm
    :init
    (dolist (hook '(emacs-lisp-mode-hook
                    lisp-mode-hook
                    scheme-mode-hook
                    clojure-mode-hook))
      (add-hook hook (lambda () (lispy-mode +1))))
    :config
    (bind-keys :map lispy-mode-map
               ("C-e" . nil)
               ("M-i" . nil)
               ("M-e" . lispy-iedit)
               ("g" . special-lispy-goto-local)
               ("G" . special-lispy-goto)))
#+END_SRC

*** Yasnippets

Snippets are keys.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package yasnippet
    :idle
    (yas-global-mode 1)
    :idle-priority 3
    :diminish (yas-minor-mode . "")
    :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
    (add-to-list 'auto-mode-alist '("\\.yasnippet$" . snippet-mode))
    (setq yas-verbosity 1)
    ;; No need to be so verbose
    (setq yas-wrap-around-region t)
    ;; Wrap around region
    (setq-default yas/prompt-functions '(yas/ido-prompt))
    (bind-key "<return>" 'yas-exit-all-snippets yas-keymap))
#+END_SRC

*** Undo-Tree

More natural undo or redo. Undo with =C-/= and redo with =C-?=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package undo-tree
    :diminish (undo-tree-mode . "")
    :config
    (global-undo-tree-mode 1))
#+END_SRC

*** Cider

#+begin_src emacs-lisp :tangle yes
  (req-package cider
    :require clojure-mode
    :config
    (setq nrepl-log-messages t)
    (setq nrepl-hide-special-buffers t)
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-repl-result-prefix ";; => ")
    (setq cider-interactive-eval-result-prefix ";; => ")
    (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
    (defun prelude-cider-repl-mode-defaults ()
      (subword-mode +1)
      (smartparens-strict-mode +1))
    (add-hook 'cider-repl-mode-hook 'prelude-cider-repl-mode-defaults))
#+end_src

*** Kibit-mode

#+begin_src emacs-lisp :tangle no
  (req-package kibit-mode
    :require clojure-mode)
#+end_src

*** Company

[[https://github.com/company-mode/company-mode][Company]] is a code completion framework for Emacs. The name stands for
"complete anything".

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package company
    :init
    (add-hook 'after-init-hook #'global-company-mode)
    :bind ("C-c y" . company-yasnippet)
    :diminish (company-mode . "")
    :config
    ;; repomacs problematic
    (my-delq-multi company-backends 'company-ropemacs)
    (setq company-tooltip-align-annotations t)
    (setq company-dabbrev-ignore-case nil)
    (setq company-dabbrev-downcase nil)
    (eval-after-load 'company-dabbrev-code
      '(dolist (mode '(coq-mode oz-mode))
         (add-to-list 'company-dabbrev-code-modes mode)))
    ;; invert the navigation direction if the the completion popup-isearch-match
    ;; is displayed on top (happens near the bottom of windows)
    (setq company-tooltip-flip-when-above t)
    (setq company-dabbrev-code-other-buffers 'code))
#+END_SRC

*** Company-ghc

#+begin_src emacs-lisp :tangle yes
  (req-package company-ghc
    :require (company ghc)
    :config
    (add-to-list 'company-backends '(company-ghc :with company-dabbrev-code)))
#+end_src

*** Shell-pop

[[https://github.com/kyagi/shell-pop-el][Shell-pop.el]] helps you to use shell easily on Emacs. Only one key
action to work.

#+BEGIN_SRC emacs-lisp :tangle no
(req-package shell-pop)
#+END_SRC

*** Flyspell

Enable spell-checking in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package flyspell
    :diminish (flyspell-mode . "")
    :init
    ;; Enable spell check in only plaintext
    (add-hook 'text-mode-hook 'flyspell-mode)
    ;; Enable spell check in comments
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    :config
    (setq flyspell-issue-welcome-flag nil)
    (setq flyspell-issue-message-flag nil)
    (setq ispell-program-name "aspell"    ; use aspell instead of ispell
          ispell-extra-args '("--sug-mode=ultra"))
    ;; Make spell check on right click.
    (define-key flyspell-mouse-map [down-mouse-3] 'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] 'undefined)
    (define-key flyspell-mode-map (kbd "C-M-i") nil)
    (define-key flyspell-mode-map (kbd "C-;") nil))

#+END_SRC

**** Helpful Default Keybindings
=C-.= corrects word at point.  =C-,​= to jump to next misspelled word.
*** Browse-kill-ring

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package browse-kill-ring
    :config
    (browse-kill-ring-default-keybindings))
#+END_SRC

*** Flycheck

A great syntax checker.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package flycheck
    :bind ("C-c L" . flycheck-list-errors)
    :init
    (if (fboundp 'global-flycheck-mode)
        (global-flycheck-mode +1)
      (add-hook 'prog-mode-hook 'flycheck-mode))
    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (setq flycheck-indication-mode 'left-fringe)
    (setq flycheck-completion-system 'ido))
#+END_SRC

*** Flycheck-haskell

#+begin_src emacs-lisp :tangle yes
  (req-package flycheck-haskell
    :require flycheck
    :init
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook #'flycheck-haskell-setup)))
#+end_src

*** Pop Win

[[https://github.com/m2ym/popwin-el][popwin]] is used to manage the size of "popup" buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package popwin
    :config
    (popwin-mode 1))
#+END_SRC

*** Multiple Cursors

[[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package multiple-cursors
    :bind (("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ("C-c C->" . mc/mark-more-like-this-extended))
    :init
    (setq mc/list-file (expand-file-name "mc-lists.el" savefile-dir)))
#+END_SRC

*** Move-text

Move lines or a region up or down.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package move-text
    :bind (("<C-S-up>" . move-text-up)
           ("<C-S-down>" . move-text-down)))
#+END_SRC

*** Guide-key

[[https://github.com/kbkbkbkb1/guide-key][Guide-key.el]] displays the available key bindings automatically and
dynamically.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package guide-key
    :diminish (guide-key-mode . "")
    :config
    (guide-key-mode 1)
    (setq guide-key/guide-key-sequence
          '("C-x r" "C-x c" "C-x 4" "C-x 5"
            (org-mode "C-c C-x")))
    (setq guide-key/popup-window-position 'bottom)
    (setq guide-key/highlight-command-regexp
          '(("rectangle" . font-lock-warning-face)
            ("register"  . font-lock-type-face))))
#+END_SRC

*** Reveal-in-finder

Open file in Finder

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package reveal-in-finder
    :if (eq system-type 'darwin)
    :bind
    ("C-c o" . reveal-in-finder))
#+END_SRC

*** Sbt-mode

[[https://github.com/hvesalai/sbt-mode][Sbt-mode]] is an emacs mode for interacting with sbt, scala console
(aka REPL) and sbt projects.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package sbt-mode
    :config
    (add-hook 'scala-mode-hook
              '(lambda ()
                 (local-set-key (kbd "M-.") 'sbt-find-definitions)
                 (local-set-key (kbd "C-x '") 'sbt-run-previous-command)))
    (add-hook 'sbt-mode-hook
              '(lambda ()
                 (setq compilation-skip-threshold 1)
                 (local-set-key (kbd "C-a") 'comint-bol)
                 (local-set-key (kbd "M-RET") 'comint-accumulate))))
#+END_SRC

*** Ensime

[[https://github.com/ensime/ensime-src][ENSIME]] is the ENhanced Scala Interaction Mode for Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package ensime
    :require scala-mode2
    :init
    (setq ensime-default-java-home
          "/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home")
    (setq ensime-default-server-root
          (expand-file-name "ensime-servers/" savefile-dir))
    :config
    (add-hook 'scala-mode-hook 'ensime-scala-mode-hook))
#+END_SRC

*** Color-identifiers-mode

[[https://github.com/ankurdave/color-identifiers-mode][Color Identifiers]] is a minor mode for Emacs that highlights each
source code identifier uniquely based on its name.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package color-identifiers-mode
    :diminish (color-identifiers-mode . "")
    :init
    (add-hook 'after-init-hook #'global-color-identifiers-mode))
#+END_SRC

*** Ebib

[[https://github.com/joostkremers/ebib][Ebib]] is a BibTeX database manager that runs in GNU Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ebib
    :config
    (setq ebib-preload-bib-files (quote ("~/research/refs.bib"))))
#+END_SRC

*** Lexbind-mode

[[https://github.com/spacebat/lexbind-mode][Lexbind-mode]] is an Emacs minor mode to display the value of the
lexical-binding variable which determines the behaviour of
variable binding forms in Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package lexbind-mode
    :config
    (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
#+END_SRC

*** Smartparens

Show matching and unmatched delimiters, and auto-close them as well.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package smartparens
    :init
    (require 'smartparens-config)
    :config
    ;; highlights matching pairs
    (setq sp-base-key-bindings 'paredit)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-hybrid-kill-entire-symbol nil)
    (sp-use-paredit-bindings)
    (sp-pair "{" nil :post-handlers
             '(((lambda (&rest _ignored)
                  (prelude-smart-open-line-above)) "RET")))
    (show-smartparens-global-mode t))
#+END_SRC

*** GHC

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ghc
    :config
    (autoload 'ghc-init "ghc" nil t)
    (add-hook 'haskell-mode-hook (lambda () (ghc-init))))
#+END_SRC

*** Structured-haskell-mode

[[https://github.com/chrisdone/structured-haskell-mode][Structured-haskell-mode]] is a minor mode providing structured editing
operations based on the syntax of Haskell.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package shm
    :config
    (add-hook 'haskell-mode-hook 'structured-haskell-mode))
#+END_SRC

*** Ace-link

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ace-link
    :config
    (ace-link-setup-default))
#+END_SRC

*** Easy-kill

[[https://github.com/leoliu/easy-kill][easy-kill]] provides commands to let users kill or mark things easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package easy-kill
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill))
#+END_SRC

*** Dash-at-point

[[Dash][http://kapeli.com/]] is an API Documentation Browser and Code Snippet
Manager. [[https://github.com/stanaka/dash-at-point][dash-at-point]] make it easy to search the word at point with
Dash.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package dash-at-point
    :if (eq system-type 'darwin))
#+END_SRC

*** Visual-regexp-steroids

[[https://github.com/benma/visual-regexp-steroids.el/][visual-regexp-steroids]] enables the use of modern regexp engines (no
more escaped group parentheses, and other goodies!).

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package visual-regexp-steroids
    :bind (("C-c r" . vr/replace)))
#+END_SRC

*** Pcre2el

[[https://github.com/joddie/pcre2el][pcre2el]] is a utility for working with regular expressions in Emacs,
based on a recursive-descent parser for regexp syntax.

#+BEGIN_SRC emacs-lisp :tangle yes
(req-package pcre2el)
#+END_SRC

*** Worf Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package worf
    :require helm
    :config
    (add-hook 'org-mode-hook 'worf-mode))
#+END_SRC

*** Skeletor

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package skeletor
    :config
    (skeletor-define-template "scala-project"
      :title "Scala Project"
      :after-creation
      (lambda (dir)
        (skeletor-async-shell-command dir "sbt \"ensime generate\" && sbt eclipse"))
      :requires-executables
      '(("sbt" . "https://github.com/sbt/sbt"))))

#+END_SRC

*** Paradox

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package paradox
    :bind ("C-S-l" . paradox-list-packages))
#+END_SRC

*** ggtags

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ggtags
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                  (ggtags-mode 1)
                  (eldoc-mode +1)
                  (setq-local eldoc-documentation-function #'ggtags-eldoc-function)))))
#+END_SRC

*** electric-spacing

#+begin_src emacs-lisp :tangle yes
  (req-package electric-spacing
    :config
    (add-hook 'org-mode-hook 'electric-spacing-mode)
    (add-to-list 'electric-spacing-regexp-pairs
                 '("\\cA\\|\\cC\\|\\ck\\|\\cK\\|\\cH" . "[0-9A-Za-z]"))
    (add-to-list 'electric-spacing-regexp-pairs
                 '("[0-9A-Za-z]" . "\\cA\\|\\cC\\|\\ck\\|\\cK\\|\\cH")))
#+end_src

*** VLFI

View Large Files in Emacs

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package vlf
    :init
    (require 'vlf-integrate)
    :config
    (setq vlf-batch-size 10240)
    (setq vlf-application 'dont-ask))
#+END_SRC
*** Anzu Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package anzu
    :diminish (anzu-mode . "")
    :config
    (global-anzu-mode +1))
#+END_SRC

*** Volatile-highlights

#+begin_src emacs-lisp :tangle no
  (req-package volatile-highlights
    :diminish (volatile-highlights-mode . "")
    :config
    (volatile-highlights-mode t))
#+end_src

*** Rebox2

#+begin_src emacs-lisp :tangle no
  (req-package rebox2
    :config
    (add-hook 'prog-mode-hook
              (lambda ()
                (set (make-local-variable 'rebox-style-loop) '(25 17 21))
                (set (make-local-variable 'rebox-min-fill-column) 40)
                (rebox-mode 1))))
#+end_src

*** Multi-term

Consult [[http://rawsyntax.com/blog/learn-emacs-zsh-and-multi-term/][Zsh and Multi-term]] for setup probelm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package multi-term
    :bind (("C-c t" . multi-term)
           ("C-c \"" . multi-term-dedicated-toggle))
    :config
    (setq multi-term-program (getenv "SHELL")
          multi-term-buffer-name "term"
          multi-term-dedicated-select-after-open-p t)
    (add-hook 'term-mode-hook
              (lambda ()
                (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
                (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))
                ;; conflict with yasnippet
                (yas-minor-mode -1)
                (company-mode -1))))
#+END_SRC

** Buffer
*** Toggle Windows

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun toggle-window-split ()
    "Toggle window splitting between horizontal to vertical."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+END_SRC

*** Indent and untabfy Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro with-region-or-buffer (func)
    "When called with no active region, call FUNC on current buffer."
    `(defadvice ,func (before with-region-or-buffer activate compile)
       (interactive
        (if mark-active
            (list (region-beginning) (region-end))
          (list (point-min) (point-max))))))

  (with-region-or-buffer indent-region)
  (with-region-or-buffer untabify)
#+END_SRC

*** Cleanup Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-cleanup-buffer-or-region ()
    "Cleanup a region if selected, otherwise the whole buffer."
    (interactive)
    (call-interactively 'untabify)
    (unless (member major-mode prelude-indent-sensitive-modes)
      (call-interactively 'indent-region))
    (whitespace-cleanup))
#+END_SRC

*** Kill other buffers

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-kill-other-buffers ()
    "Kill all buffers but the current one.
  Doesn't mess with special buffers."
    (interactive)
    (-each
        (->> (buffer-list)
          (-filter #'buffer-file-name)
          (--remove (eql (current-buffer) it)))
      #'kill-buffer)
    (message "Done"))
#+END_SRC

** Miscellaneous
*** Go to line with feedback

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line
  number input."
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (call-interactively 'goto-line))
      (linum-mode -1)))
#+END_SRC
*** Backward kill

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun backward-kill-word-or-kill-region ()
    "Kill region if there's one, otherwise kill the a word
  backward."
    (interactive)
    (call-interactively (if (region-active-p)
                            'kill-region
                          'backward-kill-word)))
#+END_SRC
*** Search

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-search (query-url prompt)
    "Open the search url constructed with the QUERY-URL.
  PROMPT sets the `read-string prompt."
    (browse-url
     (concat query-url
             (url-hexify-string
              (if mark-active
                  (buffer-substring (region-beginning) (region-end))
                (read-string prompt))))))

  (defmacro prelude-install-search-engine (search-engine-name search-engine-url search-engine-prompt)
    "Given some information regarding a search engine, install the
  interactive command to search through them"
    `(defun ,(intern (format "prelude-%s" search-engine-name)) ()
       ,(format "Search %s with a query or region if any." search-engine-name)
       (interactive)
       (prelude-search ,search-engine-url ,search-engine-prompt)))

  (prelude-install-search-engine "google" "http://www.google.com/search?q=" "Google: ")
  (prelude-install-search-engine "github" "https://github.com/search?q=" "Search GitHub: ")
#+END_SRC
*** Colorize compilation buffers

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Compilation from Emacs
  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag,
    ;; etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (require 'compile)
  (setq compilation-ask-about-save nil  ; Just save before compiling
        compilation-always-kill t       ; Just kill old compile processes before
                                          ; starting the new one
        compilation-scroll-output 'first-error ; Automatically scroll to first
                                          ; error
        )

  ;; Colorize output of Compilation Mode, see
  ;; http://stackoverflow.com/a/3072831/355252
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook #'prelude-colorize-compilation-buffer)
#+END_SRC

*** Annotate TODOs

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ov
    :config
    (defun prelude-todo-ov-evaporate (_ov _after _beg _end &optional _length)
      (let ((inhibit-modification-hooks t))
        (if _after (ov-reset _ov))))
    (defun prelude-annotate-todo ()
      "Put fringe marker on TODO: lines in the curent buffer."
      (interactive)
      (ov-set (format "[[:space:]]*%s+[[:space:]]*TODO:" comment-start)
              'before-string
              (propertize (format "A")
                          'display '(left-fringe right-triangle))
              'modification-hooks '(prelude-todo-ov-evaporate))))
#+END_SRC

*** Rename Mode Line

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))

  (rename-modeline "js2-mode" js2-mode "JS2")
  (rename-modeline "clojure-mode" clojure-mode "Clj")
  (rename-modeline "haskell-mode" haskell-mode "HS")
  (rename-modeline "scala-mode2" scala-mode "SCA")
#+END_SRC

*** Duplicate

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-get-positions-of-line-or-region ()
    "Return positions (beg . end) of the current line or region."
    (let (beg end)
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (cons beg end)))

  (defun prelude-duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated.
  However, if there's a region, all lines that region covers will
  be duplicated."
    (interactive "p")
    (pcase-let* ((origin (point))
                 (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
                 (region (buffer-substring-no-properties beg end)))
      (-dotimes arg
        (lambda (n)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point))))
      (goto-char (+ origin (* (length region) arg) arg))))

  (defun prelude-duplicate-and-comment-current-line-or-region (arg)
    "Duplicates and comments the current line or region ARG times.
  If there's no region, the current line will be duplicated.
  However, if there's a region, all lines that region covers will
  be duplicated."
    (interactive "p")
    (pcase-let* ((origin (point))
                 (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
                 (region (buffer-substring-no-properties beg end)))
      (comment-or-uncomment-region beg end)
      (setq end (line-end-position))
      (-dotimes arg
        (lambda (n)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point))))
      (goto-char (+ origin (* (length region) arg) arg))))
#+END_SRC


* Finish Requirements
All done with  =req-package=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package-finish)
#+END_SRC

