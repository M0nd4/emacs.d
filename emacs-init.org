#+AUTHOR: Jeremy Bi
#+TITLE: My Emacs Configuration

* Emacs Org Configuration

  This file is tangled using =org-babel-load-file=. What this does is
  generate a =emacs-init.el= from the =emacs-lisp= source blocks.

  This emacs.d is currently  designed for Emacs 24.3 and above.

*** Credits:

    This emacs.d was heavily inspired by the following configurations.

    [[https://github.com/daschwa/dotfiles/tree/master/emacs.d][daschwa's emacs.d]]

    [[https://github.com/bbatsov/prelude][Bozhidar Batsov's prelude]]

* Package Management

  [[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs.  It
  utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], to update a
  centralized =Cask= file when you install or remove packages.

** Cask
   Cask is initialized in =init.el= with the following:
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'cask "~/.cask/cask.el")
     (cask-initialize)
   #+END_SRC

** Pallet
   You can download all packages in your =Cask= file by using =M-x
   pallet-install=.  However, this should not be necessary.
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'pallet)
   #+END_SRC

* Packages, Modes, and Extensions

** Dependency Management with =req-package=

   Where Pallet keeps track of the packages we have installed, =req-package=
   handles all our internal package dependencies and configurations.

   Another nice thing about =req-package=, is that you no longer not
   need to specify the =:ensure= keyword, as it is added by default.

   Start using =req-package=
   #+BEGIN_SRC emacs-lisp
     (require 'req-package)
   #+END_SRC

* Essentials

  Some quick essential customizations.

  #+BEGIN_SRC emacs-lisp
    ;; Turn off mouse interface early in startup to avoid momentary display
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

    ;; Always load newest byte code
    (setq load-prefer-newer t)

    (defvar savefile-dir (expand-file-name "savefile" user-emacs-directory)
      "This folder stores all the automatically generated save/history-files.")

    (unless (file-exists-p savefile-dir)
      (make-directory savefile-dir))

    ;; Add the personal packages directory to the load-path
    (add-to-list 'load-path (concat user-emacs-directory "packages/"))

    ;; Load elisp bits collected from everywhere
    (require 'elisp)

    ;; Keep emacs custom-settings in separate file
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (load custom-file)

    ;; Start off with some sanity.
    (require 'better-defaults)

    ;; OSX specific settings
    (when (eq system-type 'darwin)
      (require 'cocoa-emacs-default))

    ;; No splash screen please
    (setq inhibit-startup-screen t)

    ;; Store all backup and autosave files in the tmp dir
    (setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))

    ;; saveplace remembers your location in a file when saving files
    (require 'saveplace)
    (setq save-place-file (expand-file-name "saveplace" savefile-dir))
    ;; activate it for all buffers
    (setq-default save-place t)

    ;; savehist keeps track of some history
    (require 'savehist)
    (setq savehist-additional-variables
          ;; search entries
          '(search ring regexp-search-ring)
          ;; save every minute
          savehist-autosave-interval 60
          ;; keep the home clean
          savehist-file (expand-file-name "savehist" savefile-dir))
    (savehist-mode +1)

    ;; save recent files
    (require 'recentf)
    (setq recentf-save-file (expand-file-name "recentf" savefile-dir)
          recentf-max-saved-items 500
          recentf-max-menu-items 15)

    ;; reduce the frequency of garbage collection by making it happen on
    (setq gc-cons-threshold (* 1024 1024 20))

    ;; autopair
    (electric-pair-mode)

    ;; enable narrowing commands
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'narrow-to-defun 'disabled nil)

    ;; enabled change region case commands
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)

    ;; enable erase-buffer command
    (put 'erase-buffer 'disabled nil)
  #+END_SRC

* Appearance

** Theme

   Set custom theme path and load theme
   #+BEGIN_SRC emacs-lisp
     (req-package zenburn-theme
       :config
       (load-theme 'zenburn t))
   #+END_SRC

** Mode Line

   #+BEGIN_SRC emacs-lisp
     (req-package smart-mode-line
       :config
       (setq sml/theme 'dark)
       (sml/setup))
   #+END_SRC

* Keybindings

** Exiting
   I don't like to quite Emacs on accident, and I find closing frames are
   more useful.

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; The mnemonic is C-t REALLY QUIT
     (bind-key "C-x r q" 'save-buffers-kill-terminal)
     (bind-key "C-x C-c" 'delete-frame)
   #+END_SRC

** Improvements
   #+BEGIN_SRC emacs-lisp
     ;; convenient line number showing
     (global-set-key [remap goto-line] 'goto-line-with-feedback)

     ;; From better defaults
     (bind-key "M-/" 'hippie-expand)
     (bind-key "C-x C-b" 'ibuffer)
     (bind-key "C-:" 'eval-expression)
     (bind-key "M-SPC" 'cycle-spacing)
     (bind-key "C-c x" 'sunrise-cd)
     (bind-key "C-c X" 'sunrise)
     (bind-key "C-c t" 'toggle-window-split)
     (bind-key "C-M-\\" 'prelude-indent-region-or-buffer)
     (bind-key "C-S-l" 'package-list-packages)
     (bind-key "C-c q" 'auto-fill-mode)
     (bind-key "C-c k" 'prelude-kill-other-buffers)
     (bind-key "M-'" 'next-error)
     (bind-key "C-c n" 'prelude-cleanup-buffer)
     (bind-key "C-M-h" 'backward-kill-word)
     (bind-key "C-x [" 'shrink-window)
     (bind-key "C-x ]" 'enlarge-window)
     (bind-key "C-c M-d" 'prelude-duplicate-and-comment-current-line-or-region)
     (bind-key "C-c d" 'prelude-duplicate-current-line-or-region)

     ;; Set Regexp Alignment
     (bind-key "C-x \\" 'align-regexp)

     ;; Font size
     (bind-key "C-+" 'text-scale-increase)
     (bind-key "C--" 'text-scale-decrease)

     ;; Indentation help
     (bind-key "C-^" 'prelude-top-join-line)

     ;; A complementary binding to the apropos-command (C-h a)
     (define-key 'help-command "A" 'apropos)

     (bind-key "C-h C-f" 'find-function)
     (bind-key "C-h C-k" 'find-function-on-key)
     (bind-key "C-h C-v" 'find-variable)
     (bind-key "C-h C-l" 'find-library)

     (global-set-key [remap kill-whole-line] 'prelude-kill-whole-line)
     (global-set-key [remap move-beginning-of-line]
                     'prelude-move-beginning-of-line)

   #+END_SRC

** Key-chord

   Key-chord maps pairs of simultaneously pressed keys to commands.

   #+BEGIN_SRC emacs-lisp
     (req-package key-chord
       :config
       (key-chord-mode +1)
       (setq key-chord-two-keys-delay 0.05)
       (key-chord-define-global "jl" 'ace-jump-line-mode)
       (key-chord-define-global "JJ" 'prelude-switch-to-previous-buffer)
       (key-chord-define-global "x1" 'delete-other-windows)
       (key-chord-define-global "xk" 'ace-window)
       (key-chord-define-global "0o" 'delete-window)
       (key-chord-define-global "xn" 'helm-mini)
       (key-chord-define-global "jk" 'magit-status)
       (key-chord-define-global "jh" 'ace-jump-word-mode)
       (key-chord-define-global "xl" 'kill-this-buffer)
       (key-chord-define-global "xm" 'helm-M-x))
   #+END_SRC

** Unbind keys

   #+BEGIN_SRC emacs-lisp
     (unbind-key "C-o")
     (unbind-key "C-x f")
   #+END_SRC

* Setups

  All packages and modes are configured here.
** Major Modes
*** Magit

    [[https://github.com/magit/magit][Magit]] is the ultimate =git= interface for Emacs.

    #+BEGIN_SRC emacs-lisp
      (req-package magit
        :diminish (magit-auto-revert-mode . "")
        :bind ("C-x g" . magit-status))
    #+END_SRC

*** Lisp

**** Emacs lisp

     #+BEGIN_SRC emacs-lisp
       (defun prelude-recompile-elc-on-save ()
         "Recompile your elc when saving an elisp file."
         (add-hook 'after-save-hook
                   (lambda ()
                     (when (file-exists-p (byte-compile-dest-file buffer-file-name))
                       (emacs-lisp-byte-compile)))
                   nil
                   t))

       (defun prelude-conditional-emacs-lisp-checker ()
         "Don't check doc style in Emacs Lisp test files."
         (let ((file-name (buffer-file-name)))
           (when (and file-name (string-match-p ".*-tests?\\.el\\'" file-name))
             (setq-local flycheck-checkers '(emacs-lisp)))))

       (defun prelude-emacs-lisp-mode-defaults ()
         "Sensible defaults for `emacs-lisp-mode'."
         (eldoc-mode +1)
         (diminish 'eldoc-mode "")
         (prelude-recompile-elc-on-save)
         (setq mode-name "EL")
         (prettify-symbols-mode +1)
         (add-hook 'eval-expression-minibuffer-setup-hook 'eldoc-mode)
         (prelude-conditional-emacs-lisp-checker))

       (add-hook 'emacs-lisp-mode-hook 'prelude-emacs-lisp-mode-defaults)

       ;; ielm is an interactive Emacs Lisp shell
       (defun prelude-ielm-mode-defaults ()
         "Sensible defaults for `ielm'."
         (whitespace-mode -1)
         (eldoc-mode +1))

       (add-hook 'ielm-mode-hook 'prelude-ielm-mode-defaults)

       (add-to-list 'auto-mode-alist '("Cask\\'" . emacs-lisp-mode))

     #+END_SRC

*** Geiser/Scheme

#+BEGIN_SRC emacs-lisp
  (req-package geiser
    :config
    (setq geiser-active-implementations '(racket)))

  (add-hook 'scheme-mode-hook
            (lambda ()
              (push '("lambda" . 955) prettify-symbols-alist)))
#+END_SRC

*** LaTex

    Sane setup for LaTeX writers.

    #+BEGIN_SRC emacs-lisp
      (req-package tex-site
        :require latex-extra
        :config
        (setq TeX-auto-save t)
        (setq TeX-parse-self t)

        (setq-default TeX-master nil)

        ;; use pdflatex
        (TeX-global-PDF-mode 1)

        ;; sensible defaults for OS X, other OSes should be covered out-of-the-box
        (when (eq system-type 'darwin)
          (setq TeX-view-program-selection
                '((output-dvi "DVI Viewer")
                  (output-pdf "PDF Viewer")
                  (output-html "HTML Viewer")))

          (setq TeX-view-program-list
                '(("DVI Viewer" "open %o")
                  ("PDF Viewer" "open %o")
                  ("HTML Viewer" "open %o"))))

        (defun prelude-latex-mode-defaults ()
          (turn-on-auto-fill)
          (add-to-list 'TeX-engine-alist-builtin
                       '(xetex "XeTeX" "xetex -shell-escape" "xelatex -shell-escape" "xetex"))
          (latex/setup-keybinds)
          (abbrev-mode +1))

        (add-hook 'LaTeX-mode-hook 'prelude-latex-mode-defaults))

    #+END_SRC

*** Org Mode

    If you are not using it, you need to start.

    #+BEGIN_SRC emacs-lisp
      (req-package org
        :config
        (require 'ox-md)
        (require 'ox-latex)

        (require 'org-velocity)
        (setq org-velocity-bucket
              (expand-file-name "emacs-init.org" user-emacs-directory))
        (bind-key "C-c v" 'org-velocity)

        (defun org-mode-defaults ()
          (turn-on-org-cdlatex)
          (turn-on-auto-fill)
          (bind-key "C-c b" 'ebib-insert-bibtex-key org-mode-map))

        (add-hook 'org-mode-hook 'org-mode-defaults)

        ;; Fontify org-mode code blocks
        (setq org-src-fontify-natively t)

        (setq org-todo-keyword-faces
              '(("TODO" . (:foreground "green" :weight bold))
                ("NEXT" :foreground "blue" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)))

        (setq org-enforce-todo-dependencies t)
        (setq org-src-tab-acts-natively t)
        (setq org-src-window-setup 'current-window)

        ;; set up latex
        (setq org-latex-create-formula-image-program 'imagemagick)

        (setq org-latex-pdf-process
              (quote ("pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                      "bibtex $(basename %b)"
                      "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                      "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f")))

        ;; Tell the latex export to use the minted package for source
        ;; code coloration.
        (add-to-list 'org-latex-packages-alist '("" "minted"))
        (setq org-latex-listings 'minted)

        (setq org-latex-minted-options
              '(("bgcolor" "mintedbg") ("frame" "single") ("framesep" "6pt")
                ("mathescape" "true") ("fontsize" "\\small")))

        ;; execute external programs.
        (org-babel-do-load-languages
         (quote org-babel-load-languages)
         (quote ((emacs-lisp . t)
                 (dot . t)
                 (ditaa . t)
                 (R . t)
                 (python . t)
                 (ruby . t)
                 (gnuplot . t)
                 (clojure . t)
                 (sh . t)
                 (haskell . t)
                 (org . t)
                 (plantuml . t)
                 (scala . t)
                 (latex . t))))

        (setq org-confirm-babel-evaluate nil))
    #+END_SRC

*** Dired and dired+

    Dired Plus is an extension to the =dired= file manager in Emacs.  My
    favorite feature is that pressing =F= will open all marked files.

    #+BEGIN_SRC emacs-lisp
      (req-package dired
        :commands dired-jump
        :config
        (put 'dired-find-alternate-file 'disabled nil)

        ;; always delete and copy recursively
        (setq dired-recursive-deletes 'always)
        (setq dired-recursive-copies 'always)

        (setq dired-dwim-target t)

        ;; enable some really cool extensions like C-x C-j(dired-jump)
        (require 'dired-x)

        (setq-default dired-omit-mode t
                      dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\."))

      (req-package dired+)
    #+END_SRC

*** Scala-mode

    #+BEGIN_SRC emacs-lisp
      (req-package scala-mode2
        :config
        (setq scala-indent:align-forms t
              scala-indent:align-parameters t)
        (defun scala-mode-hook-defaults ()
          (company-mode -1)
          (subword-mode +1))
        (add-hook 'scala-mode-hook 'scala-mode-hook-defaults))
    #+END_SRC

*** TODO Markdown

*** Eshell

    Type =clear= to clear the buffer like in other terminal emulators.

    #+BEGIN_SRC emacs-lisp
      (require 'eshell)
      (setq eshell-directory-name
              (expand-file-name "eshell" savefile-dir))

      (defun eshell/clear ()
        "Clears the shell buffer ala Unix's clear."
        ;; the shell prompts are read-only, so clear that for the duration
        (let ((inhibit-read-only t))
          ;; simply delete the region
          (erase-buffer)))

    #+END_SRC

*** Haskell Mode

#+BEGIN_SRC emacs-lisp
  (req-package haskell-mode
    :config
    (defun prelude-haskell-mode-defaults ()
      (subword-mode +1)
      (turn-on-haskell-doc-mode)
      (turn-on-haskell-simple-indent))
    (add-hook 'haskell-mode-hook
              'prelude-haskell-mode-defaults)
    (setq haskell-tags-on-save t
          haskell-process-suggest-hoogle-imports t
          haskell-process-suggest-remove-import-lines t
          haskell-process-auto-import-loaded-modules t
          haskell-process-log t)
    (define-key haskell-mode-map (kbd "C-x C-d") nil)
    (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
    (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-file)
    (define-key haskell-mode-map (kbd "C-c C-b") 'haskell-interactive-switch)
    (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
    (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
    (define-key haskell-mode-map (kbd "C-c M-.") nil)
    (define-key haskell-mode-map (kbd "C-c C-d") nil))
#+END_SRC

*** SML Mode

#+BEGIN_SRC emacs-lisp
  (req-package sml-mode
    :mode "\\.sml\\'"
    :config
    (defun my-sml-prog-proc-send-buffer ()
      "If sml repl exists, then restart it else create a new repl."
      (interactive)
      (when (get-buffer "*sml*")
        (with-current-buffer "*sml*"
          (when (get-process "sml")
            (comint-send-eof)))
        (sleep-for 0.2)
        (sml-run "sml" ""))
      (sml-prog-proc-send-buffer t))
    (bind-key "C-c C-b" 'my-sml-prog-proc-send-buffer sml-mode-map))

#+END_SRC

*** Js2 Mode

#+BEGIN_SRC emacs-lisp
  (req-package js2-mode
    :mode "\\.js\\'")
#+END_SRC

** Minor Modes
*** Pallet

    #+BEGIN_SRC emacs-lisp
      (req-package pallet)
    #+END_SRC

*** Wgrep

    [[https://github.com/mhayashi1120/Emacs-wgrep][Wgrep]] allows you to edit a grep buffer and apply those changes to the
    file buffer.

    #+BEGIN_SRC emacs-lisp
      (req-package wgrep-ag
        :require wgrep)
    #+END_SRC

*** Helm

    =helm-mini= is a part of [[https://github.com/emacs-helm/helm][Helm]] that shows current buffers and a list of
    recent files using =recentf=.  It is a great way to manage many open
    files.

    #+BEGIN_SRC emacs-lisp
      (req-package helm
        :init
        (require 'helm-config)
        :bind ("C-x C-f" . helm-find-files))
    #+END_SRC

*** Helm-swoop

    [[https://github.com/ShingoFukuyama/helm-swoop][Helm-swoop]], efficiently hopping squeezed lines powered by Emacs
    helm interface.

    #+BEGIN_SRC emacs-lisp
      (req-package helm-swoop
        :require helm
        :bind (("M-i" . helm-swoop)
               ("M-I" . helm-swoop-back-to-last-point)
               ("C-c M-i" . helm-multi-swoop)
               ("C-x M-i" . helm-multi-swoop-all))
        :config
        ;; When doing isearch, hand the word over to helm-swoop
        (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
        ;; From helm-swoop to helm-multi-swoop-all
        (bind-key "M-i" 'helm-multi-swoop-all-from-helm-swoop helm-swoop-map))
    #+END_SRC

*** Helm-descbinds

    [[https://github.com/emacs-helm/helm-descbinds][Helm Descbinds]] provides an interface to emacs' =describe-bindings=
    making the currently active key bindings interactively searchable
    with helm.

    #+BEGIN_SRC emacs-lisp
      (req-package helm-descbinds
        :require helm
        :config
        (helm-descbinds-mode 1))
    #+END_SRC

*** Fulframe

    [[https://github.com/tomterl/fullframe][Fullframe]] advises commands to execute fullscreen, restoring the window
    setup when exiting.

    #+BEGIN_SRC emacs-lisp
      (req-package fullframe
        :config
        (fullframe magit-status magit-mode-quit-window)
        (fullframe info Info-exit)
        (fullframe ibuffer ibuffer-quit))
    #+END_SRC

*** Mykie

    [[https://github.com/yuutayamada/mykie-el][Mykie]] is a command multiplexer, which can add other functions to a
    single keybind.

    #+BEGIN_SRC emacs-lisp
      (req-package mykie
        :config
        (setq mykie:use-major-mode-key-override 'global)
        (mykie:initialize)
        (mykie:set-keys nil
          "C-e"
          :default (move-end-of-line 1)
          :repeat  (end-of-buffer)
          :C-u (beginning-of-buffer)
          "C-S-n"
          :default (next-line 4)
          "C-S-p"
          :default (previous-line 4)
          "C-w"
          :default (kill-region (mark) (point))
          :minibuff (backward-kill-word 1)))
    #+END_SRC

*** Ace-window

    [[https://github.com/abo-abo/ace-window][Ace-window]] provides window switching, the visual way.

    #+BEGIN_SRC emacs-lisp
      (req-package ace-window
        :bind ("C-x o" . ace-window)
        :config
        (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
    #+END_SRC

*** Rainbow mode

    =rainbow-mode= displays hexadecimal colors with the color they
    represent as their background.

    #+BEGIN_SRC emacs-lisp
      (req-package rainbow-mode
        :diminish (rainbow-mode . "")
        :config
        (add-hook 'prog-mode-hook 'rainbow-mode))
    #+END_SRC

*** Rainbow-delimiter

    [[https://github.com/jlr/rainbow-delimiters][Rainbow Delimiters]] is a “rainbow parentheses”-like mode which
    highlights parentheses, brackets, and braces according to their depth

    #+BEGIN_SRC emacs-lisp
      (req-package rainbow-delimiters
        :config
        (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
    #+END_SRC

*** Elisp-slime-nav

    [[https://github.com/purcell/elisp-slime-nav][Elisp-slime-nav]] allows very convenient navigation to the symbol at
    point (using =M-.=), and the ability to pop back to previous marks
    (using =M-,=).

    #+BEGIN_SRC emacs-lisp
      (req-package elisp-slime-nav
        :diminish (elisp-slime-nav-mode . "")
        :config
        (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
          (add-hook hook 'elisp-slime-nav-mode)))
    #+END_SRC

*** Expand-region

    [[https://github.com/magnars/expand-region.el][Expand-region]] increases the selected region by semantic units. Just
    keep pressing the key until it selects what you want.

    #+BEGIN_SRC emacs-lisp
      (req-package expand-region
        :bind ("C-=" . er/expand-region))
    #+END_SRC

*** Whitespace

    Whitespace-mode configuration.

    #+BEGIN_SRC emacs-lisp

      (req-package whitespace
        :diminish (whitespace-mode . "")
        :config
        (setq whitespace-line-column 80) ;; limit line length
        (setq whitespace-style '(face tabs trailing lines-tail))

        (defun prelude-enable-whitespace ()
          "Enable `whitespace-mode' if `prelude-whitespace' is not nil."
          (add-hook 'before-save-hook 'whitespace-cleanup nil t)
          (whitespace-mode +1))

        (add-hook 'text-mode-hook 'prelude-enable-whitespace)
        (add-hook 'prog-mode-hook 'prelude-enable-whitespace))

    #+END_SRC

*** Ag

    [[https://github.com/Wilfred/ag.el][Ag.el]] is a simple ag frontend, loosely based on ack-and-half.el.

    #+BEGIN_SRC emacs-lisp
      (req-package ag
        :config
        (setq ag-highlight-search t))
    #+END_SRC

*** Projectile

    #+BEGIN_SRC emacs-lisp
      (req-package projectile
        :diminish ""
        :bind (("s-p" . projectile-switch-project)
               ("s-f" . projectile-find-file)
               ("s-g" . projectile-ag))
        :init
        (projectile-global-mode t)
        :config
        (setq projectile-cache-file
              (expand-file-name  "projectile.cache" savefile-dir)))
    #+END_SRC

*** Lispy

    [[https://github.com/abo-abo/lispy][Lispy]] implements various vi-like commands for navigating and editing
    Lisp code.

    #+BEGIN_SRC emacs-lisp
      (req-package lispy
        :init
        (dolist (hook '(emacs-lisp-mode-hook
                        lisp-mode-hook
                        scheme-mode-hook
                        clojure-mode))
          (add-hook hook (lambda () (lispy-mode +1))))
        :config
        (bind-keys :map lispy-mode-map
                   ("C-e" . nil)
                   ("M-i" . nil)
                   ("M-e" . lispy-iedit)
                   ("g" . special-lispy-goto-local)
                   ("G" . special-lispy-goto)))
    #+END_SRC

*** Yasnippets

    Snippets are keys.

    #+BEGIN_SRC emacs-lisp
      (req-package yasnippet
        :idle
        (yas-global-mode 1)
        :idle-priority 3
        :diminish (yas-minor-mode . "")
        :config
        (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
        (add-to-list 'auto-mode-alist '("\\.yasnippet$" . snippet-mode))
        (setq yas-verbosity 1)
        ;; No need to be so verbose
        (setq yas-wrap-around-region t)
        ;; Wrap around region
        (setq-default yas/prompt-functions '(yas/ido-prompt))
        (bind-key "<return>" 'yas-exit-all-snippets yas-keymap))
    #+END_SRC

*** Undo-Tree

    More natural undo or redo. Undo with =C-/= and redo with =C-?=.

    #+BEGIN_SRC emacs-lisp
      (req-package undo-tree
        :diminish (undo-tree-mode . "")
        :config
        (global-undo-tree-mode 1))
    #+END_SRC

*** Company

    [[https://github.com/company-mode/company-mode][Company]] is a code completion framework for Emacs. The name stands for
    "complete anything".

    #+BEGIN_SRC emacs-lisp
      (req-package company
        :init
        (add-hook 'after-init-hook #'global-company-mode)
        :diminish (company-mode . "")
        :config
        ;; repomacs problematic
        (my-delq-multi company-backends 'company-ropemacs)
        (setq company-dabbrev-ignore-case nil)
        (setq company-dabbrev-downcase nil)
        (eval-after-load 'company-dabbrev-code
          '(dolist (mode '(coq-mode oz-mode))
             (add-to-list 'company-dabbrev-code-modes mode))))
    #+END_SRC

*** Shell-pop

    [[https://github.com/kyagi/shell-pop-el][Shell-pop.el]] helps you to use shell easily on Emacs. Only one key
    action to work.

    #+BEGIN_SRC emacs-lisp
      (req-package shell-pop)
    #+END_SRC

*** Flyspell

    Enable spell-checking in Emacs.

    #+BEGIN_SRC emacs-lisp
      (req-package flyspell
        :diminish (flyspell-mode . "")
        :init
        (progn
          ;; Enable spell check in only plaintext
          (add-hook 'text-mode-hook 'flyspell-mode)
          ;; Enable spell check in comments
          (add-hook 'prog-mode-hook 'flyspell-prog-mode))
        :config
        (setq flyspell-issue-welcome-flag nil)
        (setq flyspell-issue-message-flag nil)
        (setq ispell-program-name "aspell"    ; use aspell instead of ispell
              ispell-extra-args '("--sug-mode=ultra"))
        ;; Make spell check on right click.
        (define-key flyspell-mouse-map [down-mouse-3] 'flyspell-correct-word)
        (define-key flyspell-mouse-map [mouse-3] 'undefined)
        (define-key flyspell-mode-map (kbd "C-M-i") nil)
        (define-key flyspell-mode-map (kbd "C-;") nil))

    #+END_SRC

**** Helpful Default Keybindings
     =C-.= corrects word at point.  =C-,​= to jump to next misspelled word.

*** Browse-kill-ring

    #+BEGIN_SRC emacs-lisp
      (req-package browse-kill-ring
        :config
        (browse-kill-ring-default-keybindings))
    #+END_SRC

*** Flycheck

    A great syntax checker.

    #+BEGIN_SRC emacs-lisp
      (req-package flycheck
        :bind ("C-c L" . flycheck-list-errors)
        :init
        (if (fboundp 'global-flycheck-mode)
            (global-flycheck-mode +1)
          (add-hook 'prog-mode-hook 'flycheck-mode))
        :config
        (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
        (setq flycheck-indication-mode 'left-fringe)
        (setq flycheck-completion-system 'ido))
    #+END_SRC

*** Pop Win

    [[https://github.com/m2ym/popwin-el][popwin]] is used to manage the size of "popup" buffers.

    #+BEGIN_SRC emacs-lisp
      (req-package popwin
        :config
        (popwin-mode 1))
    #+END_SRC

*** Multiple Cursors

    [[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

    #+BEGIN_SRC emacs-lisp
      (req-package multiple-cursors
        :bind (("C->" . mc/mark-next-like-this)
               ("C-<" . mc/mark-previous-like-this)
               ("C-c C-<" . mc/mark-all-like-this)
               ("C-c C->" . mc/mark-more-like-this-extended)))
    #+END_SRC

*** Move-text

    Move lines or a region up or down.

    #+BEGIN_SRC emacs-lisp
      (req-package move-text
        :bind (("<C-S-up>" . move-text-up)
               ("<C-S-down>" . move-text-down)))
    #+END_SRC

*** Guide-key

    [[https://github.com/kbkbkbkb1/guide-key][Guide-key.el]] displays the available key bindings automatically and
    dynamically.

    #+BEGIN_SRC emacs-lisp
      (req-package guide-key
        :diminish (guide-key-mode . "")
        :config
        (guide-key-mode 1)
        (setq guide-key/guide-key-sequence
              '("C-x r" "C-x c" "C-x 4" "C-x 5"
                (org-mode "C-c C-x")))
        (setq guide-key/popup-window-position 'bottom)
        (setq guide-key/highlight-command-regexp
              '(("rectangle" . font-lock-warning-face)
                ("register"  . font-lock-type-face))))
    #+END_SRC

*** Reveal-in-finder

    Open file in Finder

    #+BEGIN_SRC emacs-lisp
      (req-package reveal-in-finder
        :if (eq system-type 'darwin)
        :bind
        ("C-c o" . reveal-in-finder))
    #+END_SRC

*** Sbt-mode

    [[https://github.com/hvesalai/sbt-mode][Sbt-mode]] is an emacs mode for interacting with sbt, scala console
    (aka REPL) and sbt projects.

    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package sbt-mode
        :config
        (add-hook 'scala-mode-hook
                  '(lambda ()
                     (local-set-key (kbd "M-.") 'sbt-find-definitions)
                     (local-set-key (kbd "C-x '") 'sbt-run-previous-command)))
        (add-hook 'sbt-mode-hook
                  '(lambda ()
                     (setq compilation-skip-threshold 1)
                     (local-set-key (kbd "C-a") 'comint-bol)
                     (local-set-key (kbd "M-RET") 'comint-accumulate))))
    #+END_SRC

*** Ensime

    [[https://github.com/ensime/ensime-src][ENSIME]] is the ENhanced Scala Interaction Mode for Emacs.

    #+BEGIN_SRC emacs-lisp
      (req-package ensime
        :require scala-mode2
        :config
        (add-hook 'scala-mode-hook 'ensime-scala-mode-hook))
    #+END_SRC

*** Color-identifiers-mode

    [[https://github.com/ankurdave/color-identifiers-mode][Color Identifiers]] is a minor mode for Emacs that highlights each
    source code identifier uniquely based on its name.

    #+BEGIN_SRC emacs-lisp
      (req-package color-identifiers-mode
        :diminish (color-identifiers-mode . "")
        :init
        (add-hook 'after-init-hook #'global-color-identifiers-mode))
    #+END_SRC

*** Eyebrowse

    [[https://github.com/wasamasa/eyebrowse][Eyebrowse]] is a global minor mode for Emacs that allows you to
    manage your window configurations in a simple manner. It displays
    their current state in the modeline by default.

    #+BEGIN_SRC emacs-lisp
      (req-package eyebrowse
        :diminish ""
        :init
        (setq eyebrowse-keymap-prefix (kbd "C-c C-v"))
        :config
        (setq eyebrowse-wrap-around-p t)
        (eyebrowse-mode t))
    #+END_SRC

*** Ebib

    [[https://github.com/joostkremers/ebib][Ebib]] is a BibTeX database manager that runs in GNU Emacs.

    #+BEGIN_SRC emacs-lisp
      (req-package ebib
        :config
        (org-add-link-type
         "ebib" 'ebib
         (lambda (path desc format)
           (cond
            ((eq format 'html)
             (format "(<cite>%s</cite>)" path))
            ((eq format 'latex)
             (if (or (not desc) (equal 0 (search "cite:" desc)))
                 (format "\\cite{%s}" path)
               (format "\\cite[%s][%s]{%s}"
                       (cadr (split-string desc ";"))
                       (car (split-string desc ";")) path))))))
        (setq ebib-citation-commands
            '((any
               (("cite" "\\cite%<[%A]%>{%K}")))
              (org-mode
               (("ebib1" "[[ebib:%K]]")
                ("ebib2" "[[ebib:%K][%D]]")))
              (markdown-mode
               (("text" "@%K%< [%A]%>")
                ("paren" "[%(%<%A %>@%K%<, %A%>%; )]")
                ("year" "[-@%K%< %A%>]"))))))
    #+END_SRC

*** Lexbind-mode

    [[https://github.com/spacebat/lexbind-mode][Lexbind-mode]] is an Emacs minor mode to display the value of the
    lexical-binding variable which determines the behaviour of
    variable binding forms in Emacs Lisp.

    #+BEGIN_SRC emacs-lisp
      (req-package lexbind-mode
        :config
        (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
    #+END_SRC

*** Smartparens

Show matching and unmatched delimiters, and auto-close them as well.

#+BEGIN_SRC emacs-lisp
  (req-package smartparens
    :config
    (require 'smartparens-config)
    ;; highlights matching pairs
    (show-smartparens-global-mode t)
    (bind-key "C-M-f" 'sp-forward-sexp sp-keymap)
    (bind-key "C-M-b" 'sp-backward-sexp sp-keymap)
    (bind-key "C-M-k" 'sp-kill-sexp sp-keymap))
#+END_SRC

*** Ghc-mode

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package ghc
    :config
    (autoload 'ghc-init "ghc" nil t)
    (add-hook 'haskell-mode-hook (lambda () (ghc-init))))
#+END_SRC

*** Structured-haskell-mode

[[https://github.com/chrisdone/structured-haskell-mode][Structured-haskell-mode]] is a minor mode providing structured editing
operations based on the syntax of Haskell.

#+BEGIN_SRC emacs-lisp
  (req-package shm
    :config
    (add-hook 'haskell-mode-hook 'structured-haskell-mode))
#+END_SRC

*** Ace-link

#+BEGIN_SRC emacs-lisp
  (req-package ace-link
    :config
    (ace-link-setup-default))
#+END_SRC

*** Easy-kill

[[https://github.com/leoliu/easy-kill][easy-kill]] provides commands to let users kill or mark things easily.

#+BEGIN_SRC emacs-lisp
  (req-package easy-kill
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill))
#+END_SRC

*** Dash-at-point

[[Dash][http://kapeli.com/]] is an API Documentation Browser and Code Snippet
Manager. [[https://github.com/stanaka/dash-at-point][dash-at-point]] make it easy to search the word at point with
Dash.

#+BEGIN_SRC emacs-lisp
  (req-package dash-at-point
    :if (eq system-type 'darwin))
#+END_SRC

*** Visual-regexp-steroids

[[https://github.com/benma/visual-regexp-steroids.el/][visual-regexp-steroids]] enables the use of modern regexp engines (no
more escaped group parentheses, and other goodies!).

#+BEGIN_SRC emacs-lisp
  (req-package visual-regexp-steroids
    :bind (("C-c r" . vr/replace)))
#+END_SRC

*** Pcre2el

[[https://github.com/joddie/pcre2el][pcre2el]] is a utility for working with regular expressions in Emacs,
based on a recursive-descent parser for regexp syntax.

#+BEGIN_SRC emacs-lisp
  (req-package pcre2el)
#+END_SRC

*** Worf Mode

#+BEGIN_SRC emacs-lisp
  (req-package worf
    :config
    (add-hook 'org-mode-hook 'worf-mode))
#+END_SRC

*** Skeletor

#+BEGIN_SRC emacs-lisp
  (req-package skeletor
    :config
    (skeletor-define-template "scala-project"
      :title "Scala Project"
      :after-creation
      (lambda (dir)
        (skeletor-async-shell-command dir "sbt \"ensime generate\" && sbt eclipse"))
      :requires-executables
      '(("sbt" . "https://github.com/sbt/sbt"))))

#+END_SRC

*** Anzu Mode

#+BEGIN_SRC emacs-lisp
  (req-package anzu
    :config
    (global-anzu-mode +1))
#+END_SRC

** Buffer

*** Toggle Windows

    #+BEGIN_SRC emacs-lisp
      (defun toggle-window-split ()
        "Toggle window splitting between horizontal to vertical."
        (interactive)
        (if (= (count-windows) 2)
            (let* ((this-win-buffer (window-buffer))
                   (next-win-buffer (window-buffer (next-window)))
                   (this-win-edges (window-edges (selected-window)))
                   (next-win-edges (window-edges (next-window)))
                   (this-win-2nd (not (and (<= (car this-win-edges)
                                               (car next-win-edges))
                                           (<= (cadr this-win-edges)
                                               (cadr next-win-edges)))))
                   (splitter
                    (if (= (car this-win-edges)
                           (car (window-edges (next-window))))
                        'split-window-horizontally
                      'split-window-vertically)))
              (delete-other-windows)
              (let ((first-win (selected-window)))
                (funcall splitter)
                (if this-win-2nd (other-window 1))
                (set-window-buffer (selected-window) this-win-buffer)
                (set-window-buffer (next-window) next-win-buffer)
                (select-window first-win)
                (if this-win-2nd (other-window 1))))))
    #+END_SRC

*** Swap windowns

    #+BEGIN_SRC emacs-lisp
      (defun prelude-swap-windows ()
        "If you have 2 windows, it swaps them."
        (interactive)
        (if (/= (count-windows) 2)
            (message "You need exactly 2 windows to do this.")
          (let* ((w1 (car (window-list)))
                 (w2 (cadr (window-list)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1 b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)))
        (other-window 1))
    #+END_SRC

*** Untabify Buffer

    #+BEGIN_SRC emacs-lisp
      (defun prelude-untabify-buffer ()
        "Remove all tabs from the current buffer."
        (interactive)
        (untabify (point-min) (point-max)))
    #+END_SRC

*** Indent Buffer

    #+BEGIN_SRC emacs-lisp
      (defun prelude-indent-buffer ()
        "Indent the currently visited buffer."
        (interactive)
        (indent-region (point-min) (point-max)))

      (defun prelude-indent-region-or-buffer ()
        "Indent a region if selected, otherwise the whole buffer."
        (interactive)
        (save-excursion
          (if (region-active-p)
              (progn
                (indent-region (region-beginning) (region-end))
                (message "Indented selected region."))
            (progn
              (prelude-indent-buffer)
              (message "Indented buffer.")))))
    #+END_SRC

*** Cleanup Buffer

    #+BEGIN_SRC emacs-lisp
      (defun prelude-cleanup-buffer ()
        "Perform a bunch of operations on the whitespace content of a buffer."
        (interactive)
        (prelude-indent-buffer)
        (prelude-untabify-buffer)
        (whitespace-cleanup))
    #+END_SRC

*** Kill other buffers

    #+BEGIN_SRC emacs-lisp
      (defun prelude-kill-other-buffers ()
        "Kill all buffers but the current one.
      Doesn't mess with special buffers."
        (interactive)
        (-each
            (->> (buffer-list)
              (-filter #'buffer-file-name)
              (--remove (eql (current-buffer) it)))
          #'kill-buffer)
        (message "Done"))
    #+END_SRC

** Miscellaneous
*** Go to line with feedback

    #+BEGIN_SRC emacs-lisp
      (defun goto-line-with-feedback ()
        "Show line numbers temporarily, while prompting for the line number input."
        (interactive)
        (unwind-protect
            (progn
              (linum-mode 1)
              (call-interactively 'goto-line))
          (linum-mode -1)))
    #+END_SRC
*** Backward kill

    #+BEGIN_SRC emacs-lisp
      (defun backward-kill-word-or-kill-region ()
        "Kill region if there's one, otherwise kill the a word backward."
        (interactive)
        (call-interactively (if (region-active-p)
                                'kill-region
                              'backward-kill-word)))
    #+END_SRC
*** Search

    #+BEGIN_SRC emacs-lisp
      (defun prelude-search (query-url prompt)
        "Open the search url constructed with the QUERY-URL.
      PROMPT sets the `read-string prompt."
        (browse-url
         (concat query-url
                 (url-hexify-string
                  (if mark-active
                      (buffer-substring (region-beginning) (region-end))
                    (read-string prompt))))))

      (defmacro prelude-install-search-engine (search-engine-name search-engine-url search-engine-prompt)
        "Given some information regarding a search engine, install the interactive command to search through them"
        `(defun ,(intern (format "prelude-%s" search-engine-name)) ()
           ,(format "Search %s with a query or region if any." search-engine-name)
           (interactive)
           (prelude-search ,search-engine-url ,search-engine-prompt)))

      (prelude-install-search-engine "google" "http://www.google.com/search?q=" "Google: ")
      (prelude-install-search-engine "github" "https://github.com/search?q=" "Search GitHub: ")
    #+END_SRC
*** Colorize compilation buffers

#+BEGIN_SRC emacs-lisp
  ;; Compilation from Emacs
  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag, etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (require 'compile)
  (setq compilation-ask-about-save nil  ; Just save before compiling
        compilation-always-kill t       ; Just kill old compile processes before
                                        ; starting the new one
        compilation-scroll-output 'first-error ; Automatically scroll to first
                                               ; error
        )

  ;; Colorize output of Compilation Mode, see
  ;; http://stackoverflow.com/a/3072831/355252
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook #'prelude-colorize-compilation-buffer)
#+END_SRC

*** Duplicate

    #+BEGIN_SRC emacs-lisp
      (defun prelude-get-positions-of-line-or-region ()
        "Return positions (beg . end) of the current line
      or region."
        (let (beg end)
          (if (and mark-active (> (point) (mark)))
              (exchange-point-and-mark))
          (setq beg (line-beginning-position))
          (if mark-active
              (exchange-point-and-mark))
          (setq end (line-end-position))
          (cons beg end)))

      (defun prelude-duplicate-current-line-or-region (arg)
        "Duplicates the current line or region ARG times.
      If there's no region, the current line will be duplicated.  However, if
      there's a region, all lines that region covers will be duplicated."
        (interactive "p")
        (pcase-let* ((origin (point))
                     (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
                     (region (buffer-substring-no-properties beg end)))
          (-dotimes arg
            (lambda (n)
              (goto-char end)
              (newline)
              (insert region)
              (setq end (point))))
          (goto-char (+ origin (* (length region) arg) arg))))

      (defun prelude-duplicate-and-comment-current-line-or-region (arg)
        "Duplicates and comments the current line or region ARG times.
      If there's no region, the current line will be duplicated.  However, if
      there's a region, all lines that region covers will be duplicated."
        (interactive "p")
        (pcase-let* ((origin (point))
                     (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
                     (region (buffer-substring-no-properties beg end)))
          (comment-or-uncomment-region beg end)
          (setq end (line-end-position))
          (-dotimes arg
            (lambda (n)
              (goto-char end)
              (newline)
              (insert region)
              (setq end (point))))
          (goto-char (+ origin (* (length region) arg) arg))))
    #+END_SRC


* Finish Requirements
  All done with  =req-package=.
  #+BEGIN_SRC emacs-lisp
    (req-package-finish)
  #+END_SRC

