#+AUTHOR: Jeremy Bi
#+TITLE: My Emacs Configuration

* Emacs Org Configuration

This file is tangled using =org-babel-load-file=. What this does is
generate a =emacs-init.el= from the =emacs-lisp= source blocks.

This emacs.d is currently designed for [[https://github.com/railwaycat/homebrew-emacsmacport][Emacs Mac Port]].

I use the beautiful [[http://larsenwork.com/monoid/][Monoid]] font for coding and everything else.

*** Credits:

This emacs.d was heavily inspired by the following configurations.

[[https://github.com/daschwa/emacs.d][Adam Schwartz's emacs.d]]

[[https://github.com/bbatsov/prelude][Bozhidar Batsov's prelude]]

[[https://github.com/larstvei/dot-emacs][larstvei's dot-emacs]]

* Package Management

[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs.  It
utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], to update a
centralized =Cask= file when you install or remove packages.

** Cask

Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

** Pallet

You can download all packages in your =Cask= file by using =M-x
pallet-install=. However, this should not be necessary.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'pallet)
  (pallet-mode t)
#+END_SRC

* Packages, Modes, and Extensions

** Dependency Management with =use-package=

While Pallet keeps track of the packages we have installed,
=use-package= allows you to isolate package configuration.

Start using =use-package=
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (eval-when-compile
  ;;   (require 'use-package))
  (require 'bind-key)
  (require 'diminish)

  (require 'req-package)
#+END_SRC

** Custom Packages

Add custom packages directory.

#+begin_src emacs-lisp :tangle yes
  (defun prelude-add-subfolders-to-load-path (parent-dir)
    "Add all level PARENT-DIR subdirs to the `load-path'."
    (dolist (f (directory-files parent-dir))
      (let ((name (expand-file-name f parent-dir)))
        (when (and (file-directory-p name)
                   (not (string-prefix-p "." f)))
          (add-to-list 'load-path name)
          (prelude-add-subfolders-to-load-path name)))))

  (add-to-list 'load-path my-vendor-dir)
  (prelude-add-subfolders-to-load-path my-vendor-dir)
#+end_src

* Meta

We add a function to the =after-save-hook= ensuring to always tangle
and byte-compile the =org=-document after changes asynchronously.

[[https://github.com/jwiegley/emacs-async][async]] is a module for doing asynchronous processing in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package async
    :preface
    (defun my/init-hook ()
      "If the current buffer is 'emacs-init.org' the code-blocks
  are tangled."
      (when (equal (buffer-file-name) my-org-file)
        (async-start
         `(lambda ()
            (require 'org)
            (org-babel-tangle-file ,my-org-file))
         (lambda (result)
           (message "Tangled file compiled.")))))
    :config
    (add-hook 'after-save-hook 'my/init-hook))

  (req-package dired-async
    :require async)
#+END_SRC

* Appearance

** Theme

Set custom theme path and load theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package zenburn-theme
    :config
    (load-theme 'zenburn t))
#+END_SRC

** Mode Line

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package smart-mode-line
    :config
    (setq sml/no-confirm-load-theme t)
    (setq sml/theme nil)
    (add-hook 'after-init-hook #'sml/setup))
#+END_SRC

* Keybindings

** Improvements
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package dash
    :config
    (dash-enable-font-lock))

  (req-package elisp
    :require dash
    :bind (("M-/" . hippie-expand)
           ("C-x C-b" . ibuffer)
           ([remap goto-line] . goto-line-with-feedback)
           ("C-:" . eval-expression)
           ("M-SPC" . cycle-spacing)
           ("s-k" . kill-this-buffer)
           ("C-c k" . prelude-kill-other-buffers)
           ("C-c n" . prelude-cleanup-buffer-or-region)
           ("C-c d" . duplicate-comment-current-line-or-region)
           ("C-x b" . prelude-switch-to-previous-buffer)
           ("C-^" . prelude-top-join-line)
           ("C-x \\" . align-regexp)
           ("C-S-n" . my/forward-line-by-many)
           ("C-S-p" . my/backward-line-by-many)
           ("C-M-!" . my/iterm-shell-command)
           ([remap kill-whole-line] . prelude-kill-whole-line)
           ([(control shift return)] . prelude-smart-open-line-above))
    :bind* (("C-M-h" . backward-kill-word)))
#+END_SRC

** Key-chord

Key-chord maps pairs of simultaneously pressed keys to commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package key-chord
    :config
    (setq key-chord-two-keys-delay 0.05)
    (key-chord-define-global "x1" 'delete-other-windows)
    ;; (key-chord-define-global "xk" 'ace-window)
    (key-chord-define-global "0o" 'delete-window)
    (key-chord-define-global "jk" 'magit-status)
    (key-chord-define-global "xn" 'helm-mini)
    (key-chord-define-global "xm" 'helm-M-x)
    (key-chord-mode 1))

  ;; (req-package use-package-chords
  ;;   :require key-chord
  ;;   :config (key-chord-mode 1))
#+END_SRC

** Unbind keys

#+BEGIN_SRC emacs-lisp :tangle yes
  (unbind-key "C-o")
  (unbind-key "C-x f")
#+END_SRC

* Essentials

Some quick essential customizations.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Turn off mouse interface early in startup to avoid momentary display
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

  (unless (file-exists-p savefile-dir)
    (make-directory savefile-dir))

  ;; disable startup screen
  (setq inhibit-startup-screen t)

  ;; Start off with some sanity.
  (require 'better-defaults)

  ;; OSX specific settings
  (when (eq system-type 'darwin)
    (require 'cocoa-emacs-default))

  ;; Store all backup and autosave files in the tmp dir
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))

  ;; Make backups of files, even when they're in version control
  (setq vc-make-backup-files t)

  ;; saveplace remembers your location in a file when saving files
  (require 'saveplace)
  (setq save-place-file (expand-file-name "saveplace" savefile-dir))
  ;; activate it for all buffers
  (setq-default save-place t)

  ;; savehist keeps track of some history
  (require 'savehist)
  (setq savehist-additional-variables
        ;; search entries
        '(search ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-file (expand-file-name "savehist" savefile-dir))
  (savehist-mode +1)

  ;; bookmarks
  (require 'bookmark)
  (setq bookmark-default-file (expand-file-name "bookmarks" savefile-dir)
        bookmark-save-flag 1)

  ;; reduce the frequency of garbage collection by making it happen on
  (setq gc-cons-threshold (* 1024 1024 20))

  ;; warn when opening files bigger than 100MB
  (setq large-file-warning-threshold 100000000)

  ;; autopair
  ;; (electric-pair-mode)

  ;; enable narrowing commands
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)

  ;; enabled change region case commands
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

  ;; enable erase-buffer command
  (put 'erase-buffer 'disabled nil)

  ;; (show-paren-mode 1)
#+END_SRC

* Setups

All packages and modes are configured here.
** Major Modes

*** Lisp

**** Clojure

#+begin_src emacs-lisp :tangle no
  (use-package clojure-mode
    :ensure
    :config
    (defun my/clojure-mode-defaults ()
      (subword-mode +1)
      (smartparens-mode -1))
    (add-hook 'clojure-mode-hook 'my/clojure-mode-defaults))
#+end_src

**** Emacs lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package lisp-mode
    :preface
    (defun my/recompile-elc-on-save ()
      "Recompile your elc when saving an elisp file."
      (add-hook 'after-save-hook
                (lambda ()
                  (when (file-exists-p (byte-compile-dest-file buffer-file-name))
                    (emacs-lisp-byte-compile)))
                nil
                t))

    (defun my/conditional-emacs-lisp-checker ()
      "Don't check doc style in Emacs Lisp test files."
      (let ((file-name (buffer-file-name)))
        (when (and file-name (string-match-p ".*-tests?\\.el\\'" file-name))
          (setq-local flycheck-checkers '(emacs-lisp)))))

    (defun my/emacs-lisp-mode-defaults ()
      "Sensible defaults for `emacs-lisp-mode'."
      (my/recompile-elc-on-save)
      (smartparens-mode -1)
      (my/conditional-emacs-lisp-checker))

    ;; ielm is an interactive Emacs Lisp shell
    (defun my/ielm-mode-defaults ()
      "Sensible defaults for `ielm'."
      (whitespace-mode -1))

    :config
    (add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-mode-defaults)

    (add-hook 'ielm-mode-hook 'my/ielm-mode-defaults)

    ;; (add-to-list 'auto-mode-alist '("Cask\\'" . emacs-lisp-mode))

    :mode ("Cask\\'" . emacs-lisp-mode)

    :bind (:map
           emacs-lisp-mode-map
           ("C-c C-c" . eval-defun)
           ("C-c C-b" . eval-buffer))
    ;; (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
    ;; (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)
    )
#+END_SRC

*** Geiser/Scheme

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package geiser
  ;;   :config
  ;;   (setq geiser-active-implementations '(racket)))

  (req-package racket-mode
    :defer t
    :config
    (add-hook 'racket-mode-hook
              '(lambda ()
                 (define-key racket-mode-map (kbd "C-c C-l") 'racket-run)
                 (define-key racket-mode-map (kbd "C-c C-k") 'racket-test))))

  ;; (defun my/scheme-mode-defaults ()
  ;;   (smartparens-mode -1))

  ;; (add-hook 'scheme-mode-hook #'my/scheme-mode-defaults)
#+END_SRC

*** LaTex

Sane setup for LaTeX writers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package auctex-latexmk
    :require auctex
    :config
    (setq auctex-latexmk-inherit-TeX-PDF-mode t)
    (auctex-latexmk-setup))

  (req-package cdlatex)

  (req-package tex-site
    :defer t
    :require auctex
    :config
    (defun my/latex-mode-defaults ()
      (visual-line-mode +1)
      (yas-minor-mode -1))

    (add-hook 'LaTeX-mode-hook 'my/latex-mode-defaults)
    (add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)
    (add-to-list 'auto-mode-alist '("\\.l[gh]s\\'" . tex-mode))

    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq TeX-save-query nil)

    (setq-default TeX-master nil)

    (setq TeX-PDF-mode t)

    (when (eq system-type 'darwin)
      (setq TeX-view-program-selection
            '((output-dvi "DVI Viewer")
              (output-pdf "PDF Viewer")
              (output-html "HTML Viewer")))

      (setq TeX-view-program-list
            '(("DVI Viewer" "open %o")
              ("PDF Viewer" "open %o")
              ("HTML Viewer" "open %o")))))
#+END_SRC

*** Org Mode

If you are not using it, you need to start.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package org
    :bind (("C-c a" . org-agenda)
           ("C-c c" . org-capture)
           ("C-c l" . org-store-link))
    :config
    ;; (require 'ox-md)
    (require 'ox-latex)

    (unbind-key "C-c ;" org-mode-map)

    ;;file to save todo items
    (setq org-agenda-files (quote ("/Users/jeremybi/Dropbox/Research/todo.org")))


    ;;set priority range from A to C with default A
    (setq org-highest-priority ?A)
    (setq org-lowest-priority ?C)
    (setq org-default-priority ?A)


    ;;set colours for priorities
    (setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                               (?B . (:foreground "LightSteelBlue"))
                               (?C . (:foreground "OliveDrab"))))


    ;;open agenda in current window
    (setq org-agenda-window-setup (quote current-window))

    (setq org-capture-templates
          '(("t" "taday" entry (file+headline "/Users/jeremybi/Dropbox/Research/todo.org" "Tasks")
             "* TODO [#A] %? %t")
            ("b" "todo" entry (file+headline "/Users/jeremybi/Dropbox/Research/todo.org" "Tasks")
             "* TODO [#A] %?")))

    (defun my/org-mode-defaults ()
      ;; (turn-on-org-cdlatex)
      ;; (diminish 'org-cdlatex-mode "")
      (turn-on-auto-fill))

    (add-hook 'org-mode-hook 'my/org-mode-defaults)

    ;; Fontify org-mode code blocks
    (setq org-src-fontify-natively t)

    (setq org-todo-keywords
          (quote ((sequence "TODO(t)" "|" "CANCELLED(c@/!)" "DONE(d)"))))

    (setq org-use-fast-todo-selection t)
    (setq org-treat-S-cursor-todo-selection-as-state-change nil)
    (setq org-agenda-span 'day)

    (setq org-todo-keyword-faces
          '(("TODO" . (:foreground "green" :weight bold))
            ("NEXT" :foreground "blue" :weight bold)
            ("WAITING" :foreground "orange" :weight bold)
            ("HOLD" :foreground "magenta" :weight bold)
            ("CANCELLED" :foreground "forest green" :weight bold)))

    (setq org-enforce-todo-dependencies t)
    (setq org-src-tab-acts-natively t)

    (setq org-latex-pdf-process
          (quote ("pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                  "bibtex $(basename %b)"
                  "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                  "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f")))

    ;; Tell the latex export to use the minted package for source
    ;; code coloration.
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (setq org-latex-listings 'minted)

    (setq org-latex-minted-options
          '(("frame" "lines") ("framesep" "6pt")
            ("mathescape" "true") ("fontsize" "\\small")))

    (setq org-confirm-babel-evaluate nil)

    ;; execute external programs.
    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (dot . t)
             (ditaa . t)
             (python . t)
             (ruby . t)
             (gnuplot . t)
             (clojure . t)
             (sh . t)
             (haskell . t)
             (octave . t)
             (org . t)
             (plantuml . t)
             (scala . t)
             (sql . t)
             (latex . t))))

    (eval-after-load 'org-src
      '(define-key org-src-mode-map
         "\C-x\C-s" #'org-edit-src-exit)))
#+END_SRC

*** Dired

Dired Plus is an extension to the =dired= file manager in Emacs.  My
favorite feature is that pressing =F= will open all marked files.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package dired
    :config
    (put 'dired-find-alternate-file 'disabled nil)

    ;; always delete and copy recursively
    (setq dired-recursive-deletes 'always)
    (setq dired-recursive-copies 'always)
    ;; show readable size
    (setq dired-listing-switches "-alh")

    (setq dired-dwim-target t)

    ;; enable some really cool extensions like C-x C-j(dired-jump)
    ;; (require 'dired-x)

    (setq-default dired-omit-mode t
                  dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\."))

  (req-package dired+
    :require dired)
#+END_SRC
*** Scala-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package scala-mode2
    :config
    (setq scala-indent:align-forms t
          scala-indent:align-parameters t)
    (defun my/scala-mode-hook-defaults ()
      (subword-mode +1))
    (add-hook 'scala-mode-hook 'my/scala-mode-hook-defaults))
#+END_SRC

*** OCaml

#+begin_src emacs-lisp :tangle yes
  (req-package tuareg
    :mode ("\\.ml[ily]?$" . tuareg-mode))
#+end_src

*** Yaml mode

#+begin_src emacs-lisp :tangle yes
  (req-package yaml-mode)
#+end_src

*** Agda

#+begin_src emacs-lisp :tangle yes
  (if (executable-find "agda-mode")
      (load-file (let ((coding-system-for-read 'utf-8))
                   (shell-command-to-string "agda-mode locate"))))
#+end_src

*** Markdown

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC

*** F2j-mode

#+begin_src emacs-lisp :tangle yes
  (req-package f2j-mode)
#+end_src

*** Eshell

Type =clear= to clear the buffer like in other terminal emulators.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package eshell
    :config
    (setq eshell-directory-name
          (expand-file-name "eshell" savefile-dir))

    (defun eshell/clear ()
      "Clears the shell buffer ala Unix's clear."
      ;; the shell prompts are read-only, so clear that for the duration
      (let ((inhibit-read-only t))
        ;; simply delete the region
        (erase-buffer))))

#+END_SRC

*** Haskell Mode

I use Haskell a lot in my research, so the config bellow is very
cutting-edge (i.e., may not work out for you depending on your
platform). I use [[https://github.com/commercialhaskell/stack][stack]] for developing Haskell projects, [[https://github.com/commercialhaskell/stack-ide][stack-ide]] for
IDE-like features (precise jumping to definition, showing type, etc).

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package haskell
    :diminish (interactive-haskell-mode . "IHS")
    :config
    (defun my/haskell-mode-defaults ()
      (subword-mode +1)
      (flycheck-mode -1))

    (setq haskell-process-suggest-hoogle-imports t
          haskell-interactive-types-for-show-ambiguous nil
          haskell-process-log t
          haskell-process-type 'stack-ghci
          haskell-compile-cabal-build-command "stack build")

    (add-hook 'haskell-mode-hook 'my/haskell-mode-defaults)
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode))
#+END_SRC

*** SML Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package sml-mode
    :mode "\\.sml\\'"
    :functions sml-prog-proc-send-buffer
    :config
    (defun my-sml-prog-proc-send-buffer ()
      "If sml repl exists, then restart it else create a new repl."
      (interactive)
      (when (get-buffer "*sml*")
        (with-current-buffer "*sml*"
          (when (get-process "sml")
            (comint-send-eof)))
        (sleep-for 0.2)
        (sml-run "sml" ""))
      (sml-prog-proc-send-buffer t))
    (bind-key "C-c C-b" 'my-sml-prog-proc-send-buffer sml-mode-map))

#+END_SRC

*** Idris Mode

#+begin_src emacs-lisp :tangle yes
  (req-package idris-mode)
#+end_src

*** Lua Mode

#+begin_src emacs-lisp :tangle yes
  (req-package lua-mode)
#+end_src

*** Js2 Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package js2-mode
    :mode "\\.js\\'")
#+END_SRC

** Minor Modes
*** Recentf

#+begin_src emacs-lisp :tangle yes
  (req-package recentf
    :config
    (setq recentf-save-file (expand-file-name "recentf" savefile-dir)
          recentf-max-saved-items 60)
    (recentf-mode +1))
#+end_src

*** Company

[[https://github.com/company-mode/company-mode][Company]] is a code completion framework for Emacs. The name stands for
"complete anything".

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package company
    :diminish (company-mode . "CPY")
    :config
    (setq company-tooltip-align-annotations t)
    (setq company-idle-delay 0.3)
    (setq company-dabbrev-ignore-case nil)
    (setq company-dabbrev-downcase nil)
    (setq company-tooltip-flip-when-above t)
    (setq company-dabbrev-code-other-buffers 'code)
    (global-company-mode))
#+END_SRC

*** Company-flx

#+begin_src emacs-lisp :tangle yes
  (req-package company-flx
    :require company flx
    :config
    (company-flx-mode +1))
#+end_src

*** Ido-related

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'ido)
  (setq ido-enable-prefix nil
        ido-enable-flex-matching t
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-max-prospects 10
        ido-save-directory-list-file (expand-file-name "ido.hist" savefile-dir)
        ido-default-file-method 'selected-window
        ido-auto-merge-work-directories-length -1)
  (ido-mode +1)

  ;; disable ido faces to see flx highlights
  (setq ido-use-faces nil)
#+END_SRC

*** Macrostep

#+begin_src emacs-lisp :tangle yes
  (req-package macrostep
    :bind (:map
           emacs-lisp-mode-map
           ("C-c e" . macrostep-expand)))
#+end_src

*** Magit

[[https://github.com/magit/magit][Magit]] is the ultimate =git= interface for Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package magit
    :commands magit-status
    :config
    (setq magit-push-always-verify nil
          magit-revert-buffers t))
#+END_SRC
*** hindent

=stack install hindent= to install the binary.

#+begin_src emacs-lisp :tangle yes
  (req-package hindent
    :require haskell-mode
    :config
    (setq hindent-style "gibiansky")
    (add-hook 'haskell-mode-hook #'hindent-mode))
#+end_src

*** iedit

#+begin_src emacs-lisp :tangle yes
  (req-package iedit)
#+end_src

*** osx-trash

#+begin_src emacs-lisp :tangle yes
  (req-package osx-trash
    :config
    (osx-trash-setup))
#+end_src

*** ranger

#+begin_src emacs-lisp :tangle no
  (req-package ranger
    :require dired
    :bind* ("C-x C-j" . ranger))
#+end_src

*** quickrun

#+begin_src emacs-lisp :tangle yes
  (req-package quickrun)
#+end_src
*** Wgrep

[[https://github.com/mhayashi1120/Emacs-wgrep][Wgrep]] allows you to edit a grep buffer and apply those changes to the
file buffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package wgrep-ag
    :config
    (add-hook 'ag-mode-hook 'wgrep-ag-setup))
#+END_SRC
*** repl-toggle

#+begin_src emacs-lisp :tangle no
  (req-package repl-toggle
    :config
    (setq rtog/fullscreen t)
    (setq rtog/goto-buffer-fun 'pop-to-buffer)
    (setq rtog/mode-repl-alist '((tuareg-mode . utop))))
#+end_src

*** goto-chg

#+begin_src emacs-lisp :tangle yes
  (req-package goto-chg
    :bind* ("C-M-." . goto-last-change))
#+end_src

*** gscholar bibtex

#+begin_src emacs-lisp :tangle yes
  (req-package gscholar-bibtex)
#+end_src

*** eyebrowse

#+begin_src emacs-lisp :tangle yes
  (req-package eyebrowse
    :config
    (eyebrowse-mode t))
#+end_src

*** Helm

=helm-mini= is a part of [[https://github.com/emacs-helm/helm][Helm]] that shows current buffers and a list of
recent files using =recentf=.  It is a great way to manage many open
files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm
    :bind (("M-y" . helm-show-kill-ring)
           ("C-x C-f" . helm-find-files)
           ("C-c C-r" . helm-resume))
    :commands (helm-mini helm-M-x helm-projectile-switch-project)
    :config
    (require 'helm-config)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-quick-update                     t
          helm-split-window-in-side-p           t
          helm-M-x-fuzzy-match                  t
          helm-mode-fuzzy-match                 t
          helm-apropos-fuzzy-match              t
          helm-buffers-fuzzy-matching           t
          helm-recentf-fuzzy-match              t
          helm-move-to-line-cycle-in-source     t
          helm-ff-search-library-in-sexp        t
          helm-ff-file-name-history-use-recentf t)

    ;; show minibuffer history with Helm
    (bind-key "C-c C-l" 'helm-minibuffer-history minibuffer-local-map)

    ;; shell history.
    (bind-key "C-c C-l" 'helm-comint-input-ring shell-mode-map)
    (helm-mode +1))

#+END_SRC

*** Helm-flx

#+begin_src emacs-lisp :tangle yes
  (req-package helm-flx
    :require helm flx
    :config
    (helm-flx-mode +1))
#+end_src

*** Helm-fuzzier

#+begin_src emacs-lisp :tangle yes
  (req-package helm-fuzzier
    :require helm
    :config
    (helm-fuzzier-mode 1))
#+end_src

*** zop-to-char

#+begin_src emacs-lisp :tangle yes
  (req-package zop-to-char
    :bind ("M-z" . zop-to-char))
#+end_src

*** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] make Emacs bindings that stick around.

#+begin_src emacs-lisp :tangle yes
  (req-package hydra
    :require helm
    :config
    (hydra-add-font-lock)

    (require 'windmove)

    (defun hydra-move-splitter-left (arg)
      "Move window splitter left."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (shrink-window-horizontally arg)
        (enlarge-window-horizontally arg)))

    (defun hydra-move-splitter-right (arg)
      "Move window splitter right."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (enlarge-window-horizontally arg)
        (shrink-window-horizontally arg)))

    (defun hydra-move-splitter-up (arg)
      "Move window splitter up."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (enlarge-window arg)
        (shrink-window arg)))

    (defun hydra-move-splitter-down (arg)
      "Move window splitter down."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (shrink-window arg)
        (enlarge-window arg)))

    (global-set-key
     (kbd "C-x t")
     (defhydra hydra-toggle (:color teal)
       "
  _a_ abbrev-mode:      %`abbrev-mode
  _d_ debug-on-error    %`debug-on-error
  _f_ auto-fill-mode    %`auto-fill-function
  _t_ truncate-lines    %`truncate-lines

  "
       ("a" abbrev-mode nil)
       ("d" toggle-debug-on-error nil)
       ("f" auto-fill-mode nil)
       ("t" toggle-truncate-lines nil)
       ("q" nil "cancel")))

    (key-chord-define-global
     "ds"
     (defhydra hydra-zoom ()
       "zoom"
       ("j" text-scale-increase "in")
       ("k" text-scale-decrease "out")
       ("0" (text-scale-set 0) "reset")
       ("1" (text-scale-set 0) :bind nil)
       ("2" (text-scale-set 0) :bind nil :color blue)))

    (defhydra hydra-error (global-map "M-g")
      "goto-error"
      ("h" flycheck-list-errors "first")
      ("j" flycheck-next-error "next")
      ("k" flycheck-previous-error "prev")
      ("v" recenter-top-bottom "recenter")
      ("q" nil "quit"))

    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window (:color amaranth)
       "
  Move Point^^^^   Move Splitter   ^Ace^                       ^Split^
  --------------------------------------------------------------------------------
  _w_, _<up>_      Shift + Move    _C-a_: ace-window           _2_: split-window-below
  _a_, _<left>_                    _C-s_: ace-window-swap      _3_: split-window-right
  _s_, _<down>_                    _C-d_: ace-window-delete    ^ ^
  _d_, _<right>_                   ^   ^                       ^ ^
  You can use arrow-keys or WASD.
  "
       ("2" split-window-below nil)
       ("3" split-window-right nil)
       ("a" windmove-left nil)
       ("s" windmove-down nil)
       ("w" windmove-up nil)
       ("d" windmove-right nil)
       ("A" hydra-move-splitter-left nil)
       ("S" hydra-move-splitter-down nil)
       ("W" hydra-move-splitter-up nil)
       ("D" hydra-move-splitter-right nil)
       ("<left>" windmove-left nil)
       ("<down>" windmove-down nil)
       ("<up>" windmove-up nil)
       ("<right>" windmove-right nil)
       ("<S-left>" hydra-move-splitter-left nil)
       ("<S-down>" hydra-move-splitter-down nil)
       ("<S-up>" hydra-move-splitter-up nil)
       ("<S-right>" hydra-move-splitter-right nil)
       ("C-a" ace-window nil)
       ("u" hydra--universal-argument nil)
       ("C-s" (lambda () (interactive) (ace-window 4)) nil)
       ("C-d" (lambda () (interactive) (ace-window 16)) nil)
       ("q" nil "quit")))

    (defhydra hydra-org-template (:color blue :hint nil)
      "
  _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
  _l_atex   _E_xample   _p_erl          _i_ndex:
  _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
  _s_rc     ^ ^         plant_u_ml      _H_TML:
  _h_tml    ^ ^         ^ ^             _A_SCII:
  "
      ("s" (hot-expand "<s"))
      ("E" (hot-expand "<e"))
      ("q" (hot-expand "<q"))
      ("v" (hot-expand "<v"))
      ("c" (hot-expand "<c"))
      ("l" (hot-expand "<l"))
      ("h" (hot-expand "<h"))
      ("a" (hot-expand "<a"))
      ("L" (hot-expand "<L"))
      ("i" (hot-expand "<i"))
      ("e" (progn
             (hot-expand "<s")
             (insert "emacs-lisp")
             (forward-line)))
      ("p" (progn
             (hot-expand "<s")
             (insert "perl")
             (forward-line)))
      ("u" (progn
             (hot-expand "<s")
             (insert "plantuml :file CHANGE.png")
             (forward-line)))
      ("P" (progn
             (insert "#+HEADERS: :results output :exports both :shebang \"#!/usr/bin/env perl\"\n")
             (hot-expand "<s")
             (insert "perl")
             (forward-line)))
      ("I" (hot-expand "<I"))
      ("H" (hot-expand "<H"))
      ("A" (hot-expand "<A"))
      ("<" self-insert-command "ins")
      ("o" nil "quit"))

    (defun hot-expand (str)
      "Expand org template."
      (insert str)
      (org-try-structure-completion))

    (with-eval-after-load "org"
      (define-key org-mode-map "<"
        (lambda () (interactive)
          (if (looking-back "^")
              (hydra-org-template/body)
            (self-insert-command 1))))))

  (global-set-key
   (kbd "s-f")
   (defhydra hydra-projectile (:color blue :columns 4)
     "Projectile"
     ("a" helm-projectile-ag "ag")
     ("b" helm-projectile-switch-to-buffer "switch to buffer")
     ("c" projectile-invalidate-cache "cache clear")
     ("d" helm-projectile-find-dir "dir")
     ("f" helm-projectile-find-file "file")
     ;; ("ff" projectile-find-file-dwim "file dwim")
     ;; ("fd" projectile-find-file-in-directory "file curr dir")
     ("g" ggtags-update-tags "update gtags")
     ("i" projectile-ibuffer "Ibuffer")
     ("K" projectile-kill-buffers "Kill all buffers")
     ("o" projectile-multi-occur "multi-occur")
     ("p" helm-projectile-switch-project "switch")
     ("r" projectile-run-async-shell-command-in-root "run shell command")
     ("x" projectile-remove-known-project "remove known")
     ("X" projectile-cleanup-known-projects "cleanup non-existing")
     ("z" projectile-cache-current-file "cache current")
     ("q" nil "cancel")))
#+end_src

*** Corral

#+begin_src emacs-lisp :tangle no
  (req-package corral
    :config
    (setq corral-preserve-point t)
    (defhydra hydra-corral (:columns 4)
      "Corral"
      ("(" corral-parentheses-backward "Back")
      (")" corral-parentheses-forward "Forward")
      ("[" corral-brackets-backward "Back")
      ("]" corral-brackets-forward "Forward")
      ("{" corral-braces-backward "Back")
      ("}" corral-braces-forward "Forward")
      ("." hydra-repeat "Repeat"))
    (global-set-key (kbd "C-c c") #'hydra-corral/body))
#+end_src

*** flycheck-tip

#+begin_src emacs-lisp :tangle yes
  (req-package flycheck-pos-tip
    :require flycheck
    :config
    (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages))
#+end_src

*** Pandoc-mode

#+begin_src emacs-lisp :tangle yes
  (req-package pandoc-mode
    :require markdown-mode
    :config
    (add-hook 'markdown-mode-hook 'pandoc-mode)
    (add-hook 'org-mode-hook 'pandoc-mode)
    (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings))
#+end_src
*** Elpy

#+begin_src emacs-lisp :tangle yes
  (req-package elpy
    :config
    (remove-hook 'elpy-modules 'elpy-module-flymake)
    (remove-hook 'elpy-modules 'elpy-module-yasnippet)
    (diminish 'elpy-mode "☕")
    (elpy-enable)
    ;; (elpy-use-ipython)
    )
#+end_src
*** Py-autopep8

#+begin_src emacs-lisp :tangle yes
  (req-package py-autopep8
    :require elpy
    :config
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+end_src

*** Beacon

#+begin_src emacs-lisp :tangle yes
  (req-package beacon
    :diminish (beacon-mode . "")
    :config
    (beacon-mode 1))
#+end_src

*** mwim

Move to the beginning/end of line or code

#+begin_src emacs-lisp :tangle yes
  (req-package mwim
    :bind ("C-a" . mwim-beginning-of-code-or-line))
#+end_src
*** Helm-descbinds

[[https://github.com/emacs-helm/helm-descbinds][Helm Descbinds]] provides an interface to emacs' =describe-bindings=
making the currently active key bindings interactively searchable
with helm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-descbinds
    :require helm
    :bind ("C-c b" . helm-descbinds))
#+END_SRC

*** Fullframe

[[https://github.com/tomterl/fullframe][Fullframe]] advises commands to execute fullscreen, restoring the window
setup when exiting.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package fullframe
    :config
    (fullframe magit-status magit-mode-quit-window)
    (fullframe ibuffer ibuffer-quit))
#+END_SRC

*** Exec-path-from-shell

A GNU Emacs library to setup environment variables from the user's
shell.

#+begin_src emacs-lisp :tangle yes
  (req-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :config
    (setq exec-path-from-shell-check-startup-files nil)
    (exec-path-from-shell-initialize))
#+end_src

*** Ace-window

[[https://github.com/abo-abo/ace-window][Ace-window]] provides window switching, the visual way.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ace-window
    :bind ("s-w" . ace-window)
    :config
    (setq aw-background nil)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

*** avy

#+begin_src emacs-lisp :tangle yes
  (req-package avy
    :bind ("s-l" . avy-goto-line)
    :config
    (setq avy-background t)
    (setq avy-styles-alist '((avy-goto-word-or-subword-1 . de-brujin)))
    (bind-key "s-." 'avy-goto-word-or-subword-1))
#+end_src

*** Swiper

#+begin_src emacs-lisp :tangle yes
  (req-package swiper
    :require ivy
    :bind (("C-r" . swiper)
           ("C-s" . swiper)
           ;; ("C-c C-r" . ivy-resume)
           )
    :config
    ;; (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    ;; (setq ivy-display-style 'fancy)
    ;; (setq ivy-format-function 'ivy-format-function-arrow)
    )
#+end_src

*** Counsel

#+begin_src emacs-lisp :tangle no
  (use-package counsel
    :ensure
    :bind (("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("C-x C-f" . counsel-find-file)
           ;; ("C-c j" . counsel-git-grep)
           ("M-x" . counsel-M-x))
    :config
    (setq counsel-find-file-at-point t)
    (ivy-set-actions
     'counsel-find-file
     `((,(propertize "delete" 'face 'font-lock-warning-face)
        (lambda (x) (delete-file (expand-file-name x ivy--directory))))))
    (use-package smex :ensure))
#+end_src

*** Rainbow mode

=rainbow-mode= displays hexadecimal colors with the color they
represent as their background.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package rainbow-mode
    :diminish (rainbow-mode . "")
    :config
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

*** Expand-region

[[https://github.com/magnars/expand-region.el][Expand-region]] increases the selected region by semantic units. Just
keep pressing the key until it selects what you want.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package expand-region
    :bind ("M-2" . er/expand-region))
#+END_SRC

*** Whitespace

Whitespace-mode configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package whitespace
    :diminish (whitespace-mode . "")
    :config
    ;; (setq whitespace-line-column 80)
    (setq whitespace-style '(face tabs trailing))

    (add-hook 'text-mode-hook 'whitespace-mode)
    (add-hook 'prog-mode-hook 'whitespace-mode))

#+END_SRC

*** Whitespace-cleanup-mode

#+begin_src emacs-lisp :tangle yes
  (req-package whitespace-cleanup-mode
    :require whitespace
    :diminish (whitespace-cleanup-mode . "")
    :config
    (add-hook 'prog-mode-hook 'whitespace-cleanup-mode))
#+end_src

*** Projectile

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package projectile
    :diminish ""
    :config
    (setq projectile-cache-file
          (expand-file-name  "projectile.cache" savefile-dir)
          projectile-completion-system 'helm
          projectile-sort-order 'modification-time)
    (projectile-global-mode t))
#+END_SRC

*** Helm-projectile

#+begin_src emacs-lisp :tangle yes
  (req-package helm-projectile
    :require projectile helm)
#+end_src

*** Helm-ag

#+begin_src emacs-lisp :tangle yes
  (req-package helm-ag
    :require helm
    :defer t
    :config
    (setq helm-ag-base-command "ag --nocolor --nogroup --ignore-case"
          helm-ag-command-option "--all-text"
          helm-ag-insert-at-point 'symbol))
#+end_src

*** Lispy

[[https://github.com/abo-abo/lispy][Lispy]] implements various vi-like commands for navigating and editing
Lisp code.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package lispy
    :defer 2
    :init
    (dolist (hook '(emacs-lisp-mode-hook
                    lisp-mode-hook
                    scheme-mode-hook
                    clojure-mode-hook))
      (add-hook hook (lambda () (lispy-mode +1))))
    :config
    (bind-keys :map lispy-mode-map
               ("C-e" . nil)
               ("/" . nil)
               ("M-i" . nil)
               ("M-e" . lispy-iedit)
               ("S" . special-lispy-splice)
               ("g" . special-lispy-goto-local)
               ("G" . special-lispy-goto)))
#+END_SRC

*** Yasnippets

Snippets are keys.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package yasnippet
    :diminish (yas-minor-mode . "")
    :config
    (add-to-list 'auto-mode-alist '("\\.yasnippet$" . snippet-mode))
    (setq yas-verbosity 1)
    (setq yas-wrap-around-region t)
    (setq-default yas-prompt-functions '(yas-ido-prompt))
    (bind-key "<return>" 'yas-exit-all-snippets yas-keymap)
    (yas-global-mode 1))
#+END_SRC

*** Undo-Tree

More natural undo or redo. Undo with =C-/= and redo with =C-?=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package undo-tree
    :diminish (undo-tree-mode . "")
    :config
    (global-undo-tree-mode 1))
#+END_SRC

*** Cider

#+begin_src emacs-lisp :tangle no
  (use-package cider
    :ensure
    :defer 3
    :config
    (setq nrepl-log-messages t)
    (setq nrepl-hide-special-buffers t)
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-repl-result-prefix ";; => ")
    (setq cider-interactive-eval-result-prefix ";; => ")
    ;; (add-hook 'cider-mode-hook 'eldoc-mode)
    (defun my/cider-repl-mode-defaults ()
      (subword-mode +1)
      (smartparens-strict-mode +1))
    (add-hook 'cider-repl-mode-hook 'my/cider-repl-mode-defaults))
#+end_src

*** Merlin and utop

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Setup environment variables using opam
  (dolist (var (car (read-from-string (shell-command-to-string "opam config env --sexp"))))
    (setenv (car var) (cadr var)))

  (req-package merlin
    :require company
    :config
    (bind-keys :map merlin-mode-map
               ("M-." . merlin-locate)
               ("M-," . merlin-pop-stack))
    ;; Start merlin on ocaml files
    (add-hook 'tuareg-mode-hook 'merlin-mode t)
    (add-hook 'caml-mode-hook 'merlin-mode t)
    ;; Use opam switch to lookup ocamlmerlin binary
    (setq merlin-command 'opam))

  (req-package utop
    :config
    (add-hook 'tuareg-mode-hook 'utop-minor-mode))
#+END_SRC

*** ocp-indent

#+begin_src emacs-lisp :tangle yes
  (req-package ocp-indent)
#+end_src

*** Company-ghc

#+begin_src emacs-lisp :tangle yes
  (req-package company-ghc
    :require company
    :config
    (add-to-list 'company-backends '(company-ghc :with company-dabbrev-code)))
#+end_src
*** Company-math

#+begin_src emacs-lisp :tangle yes
  (req-package company-math
    :require company
    :config
    ;; global activation of the unicode symbol completion
    (add-to-list 'company-backends 'company-math-symbols-unicode)
    ;; local configuration for TeX modes
    (defun my/latex-mode-setup ()
      (setq-local company-backends
                  (append '(company-math-symbols-latex company-latex-commands)
                          company-backends)))

    (add-hook 'TeX-mode-hook 'my/latex-mode-setup))
#+end_src

*** Company-coq

#+begin_src emacs-lisp :tangle yes
  (req-package company-coq
    :require company
    :config
    ;; Load company-coq when opening Coq files
    (setq company-coq-prettify-symbols nil)
    (add-hook 'coq-mode-hook #'company-coq-initialize))
#+end_src

*** Flyspell

Enable spell-checking in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package flyspell
    :diminish (flyspell-mode . "")
    :config
    (setq flyspell-issue-welcome-flag nil)
    (setq flyspell-issue-message-flag nil)
    (setq ispell-program-name "aspell"    ; use aspell instead of ispell
          ispell-extra-args '("--sug-mode=ultra"))
    ;; Make spell check on right click.
    (define-key flyspell-mouse-map [down-mouse-3] 'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] 'undefined)
    (define-key flyspell-mode-map (kbd "C-M-i") nil)
    (define-key flyspell-mode-map (kbd "C-;") nil)

    ;; Enable spell check in only plaintext
    (add-hook 'text-mode-hook 'flyspell-mode)
    ;; Enable spell check in comments
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))

#+END_SRC

**** Helpful Default Keybindings
=C-.= corrects word at point.  =C-,​= to jump to next misspelled word.
*** Browse-kill-ring

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package browse-kill-ring
    :config
    (browse-kill-ring-default-keybindings))
#+END_SRC

*** Flycheck

A great syntax checker.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package flycheck
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (setq flycheck-indication-mode nil))
#+END_SRC

*** Flycheck-haskell

#+begin_src emacs-lisp :tangle no
  (use-package flycheck-haskell
    :ensure
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
#+end_src

*** Pop Win

[[https://github.com/m2ym/popwin-el][popwin]] is used to manage the size of "popup" buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package popwin
    :config
    (popwin-mode 1))
#+END_SRC

*** Multiple Cursors

[[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package multiple-cursors
    :bind (("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ("C-c C->" . mc/mark-more-like-this-extended))
    :init
    (setq mc/list-file (expand-file-name "mc-lists.el" savefile-dir)))
#+END_SRC

*** Move-text

Move lines or a region up or down.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package move-text
    :bind (("<C-M-up>" . move-text-up)
           ("<C-M-down>" . move-text-down)))
#+END_SRC

*** Reveal-in-osx-finder

Open file in Finder

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package reveal-in-osx-finder
    :if (eq system-type 'darwin)
    :bind
    ("C-c o" . reveal-in-osx-finder))
#+END_SRC

*** Sbt-mode

[[https://github.com/hvesalai/sbt-mode][Sbt-mode]] is an emacs mode for interacting with sbt, scala console
(aka REPL) and sbt projects.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package sbt-mode
    :config
    (add-hook 'scala-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-x '") 'sbt-run-previous-command)))
    (add-hook 'sbt-mode-hook
              '(lambda ()
                 (setq compilation-skip-threshold 1)
                 (local-set-key (kbd "C-a") 'comint-bol)
                 (local-set-key (kbd "M-RET") 'comint-accumulate))))
#+END_SRC

*** Ensime

[[https://github.com/ensime/ensime-src][ENSIME]] is the ENhanced Scala Interaction Mode for Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ensime
    :defer 2
    :ensure
    :config
    (add-hook 'scala-mode-hook 'ensime-scala-mode-hook))
#+END_SRC

*** Ebib

[[https://github.com/joostkremers/ebib][Ebib]] is a BibTeX database manager that runs in GNU Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ebib)
#+END_SRC

*** Lexbind-mode

[[https://github.com/spacebat/lexbind-mode][Lexbind-mode]] is an Emacs minor mode to display the value of the
lexical-binding variable which determines the behaviour of
variable binding forms in Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package lexbind-mode
    :config
    (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
#+END_SRC

*** Smartparens

Show matching and unmatched delimiters, and auto-close them as well.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package smartparens-config
    :require smartparens
    :config
    ;; (use-package smartparens-config)
    ;; ;; highlights matching pairs
    ;; (setq sp-base-key-bindings 'paredit)
    ;; (setq sp-autoskip-closing-pair 'always)
    ;; (sp-use-paredit-bindings)
    ;; (sp-pair "{" nil :post-handlers
    ;;          '(((lambda (&rest _ignored)
    ;;               (prelude-smart-open-line-above)) "RET")))
    (show-smartparens-global-mode t)

    (add-hook 'prog-mode-hook 'turn-on-smartparens-mode)
    (add-hook 'markdown-mode-hook 'turn-on-smartparens-mode))
#+END_SRC

*** GHC

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ghc
    :require haskell-mode
    :config
    (autoload 'ghc-init "ghc" nil t)
    (autoload 'ghc-debug "ghc" nil t)
    (setq ghc-ghc-options '("-fno-warn-unused-do-bind"))
    (setq ghc-report-errors nil)
    (setq ghc-display-error 'minibuffer)
    (bind-keys :map interactive-haskell-mode-map
               ("M-," . xref-pop-marker-stack)
               ("M-p" . ghc-goto-prev-error)
               ("M-n" . ghc-goto-next-error)
               ("C-c C-b" . ghc-show-type)
               ("C-c C-i" . ghc-show-info)
               ("C-c C-c" . ghc-toggle-check-command))
    (add-hook 'haskell-mode-hook (lambda () (ghc-init))))
#+END_SRC

*** Ace-link

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ace-link
    :require avy
    :config
    (ace-link-setup-default))
#+END_SRC

*** Easy-kill

[[https://github.com/leoliu/easy-kill][easy-kill]] provides commands to let users kill or mark things easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package easy-kill
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill))
#+END_SRC

*** Dash-at-point

Dash is an API Documentation Browser and Code Snippet
Manager. [[https://github.com/stanaka/dash-at-point][dash-at-point]] make it easy to search the word at point with
Dash.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package dash-at-point
    :if (eq system-type 'darwin))
#+END_SRC

*** Visual-regexp-steroids

[[https://github.com/benma/visual-regexp-steroids.el/][visual-regexp-steroids]] enables the use of modern regexp engines (no
more escaped group parentheses, and other goodies!).

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package visual-regexp
    :require visual-regexp-steroids
    :bind (("C-c r" . vr/replace)
           ("C-c q" . vr/query-replace)))
#+END_SRC

*** Worf Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package worf
    :require org
    :defer t
    :init
    (add-hook 'org-mode-hook 'worf-mode))
#+END_SRC

*** ggtags

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ggtags
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                  (ggtags-mode 1)
                  (setq-local eldoc-documentation-function #'ggtags-eldoc-function)))))
#+END_SRC

*** VLFI

View Large Files in Emacs

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package vlf-setup
    :require vlf
    :config
    (setq vlf-batch-size 10240)
    (setq vlf-application 'dont-ask))
#+END_SRC
*** Anzu Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package anzu
    :bind (("M-%" . anzu-query-replace)
           ("C-M-%" . anzu-query-replace-regexp))
    :diminish (anzu-mode . "")
    :init
    (global-anzu-mode +1))
#+END_SRC

*** Volatile-highlights

#+begin_src emacs-lisp :tangle no
  (use-package volatile-highlights
    :diminish (volatile-highlights-mode . "")
    :config
    (volatile-highlights-mode t))
#+end_src

*** Multi-term

Consult [[http://rawsyntax.com/blog/learn-emacs-zsh-and-multi-term/][Zsh and Multi-term]] for setup probelm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package multi-term
    :bind (("C-c t" . multi-term)
           ("C-c \"" . multi-term-dedicated-toggle))
    :config
    (setq multi-term-program (getenv "SHELL")
          multi-term-buffer-name "term"
          multi-term-dedicated-select-after-open-p t)
    (add-hook 'term-mode-hook
              (lambda ()
                (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
                (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))
                ;; conflict with yasnippet
                (yas-minor-mode -1)
                (company-mode -1))))
#+END_SRC

*** Git-timemachine

#+begin_src emacs-lisp :tangle yes
  (req-package git-timemachine)
#+end_src

*** Fix-word

#+begin_src emacs-lisp :tangle no
  (use-package fix-word
    :ensure
    :bind (("M-u" . fix-word-upcase)
           ("M-l" . fix-word-downcase)
           ("M-c" . fix-word-capitalize)))
#+end_src

** Buffer
*** Toggle Windows

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun toggle-window-split ()
    "Toggle window splitting between horizontal to vertical."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+END_SRC

*** Indent and untabfy Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro with-region-or-buffer (func)
    "When called with no active region, call FUNC on current buffer."
    `(defadvice ,func (before with-region-or-buffer activate compile)
       (interactive
        (if mark-active
            (list (region-beginning) (region-end))
          (list (point-min) (point-max))))))

  (with-region-or-buffer indent-region)
  (with-region-or-buffer untabify)
#+END_SRC

** Miscellaneous
*** Search

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-search (query-url prompt)
    "Open the search url constructed with the QUERY-URL.
  PROMPT sets the `read-string prompt."
    (browse-url
     (concat query-url
             (url-hexify-string
              (if mark-active
                  (buffer-substring (region-beginning) (region-end))
                (read-string prompt))))))

  (defmacro prelude-install-search-engine (search-engine-name search-engine-url search-engine-prompt)
    "Given some information regarding a search engine, install the
  interactive command to search through them"
    `(defun ,(intern (format "prelude-%s" search-engine-name)) ()
       ,(format "Search %s with a query or region if any." search-engine-name)
       (interactive)
       (prelude-search ,search-engine-url ,search-engine-prompt)))

  (prelude-install-search-engine "google" "http://www.google.com/search?q=" "Google: ")
  (prelude-install-search-engine "github" "https://github.com/search?q=" "Search GitHub: ")
#+END_SRC
*** Colorize compilation buffers

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Compilation from Emacs
  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag,
    ;; etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (require 'compile)
  (setq compilation-ask-about-save nil  ; Just save before compiling
        compilation-always-kill t       ; Just kill old compile processes before
                                          ; starting the new one
        compilation-scroll-output 'first-error ; Automatically scroll to first
                                          ; error
        )

  ;; Colorize output of Compilation Mode, see
  ;; http://stackoverflow.com/a/3072831/355252
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook #'prelude-colorize-compilation-buffer)
#+END_SRC

*** Annotate TODOs

#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ov
    :config
    (defun prelude-todo-ov-evaporate (_ov _after _beg _end &optional _length)
      (let ((inhibit-modification-hooks t))
        (if _after (ov-reset _ov))))
    (defun prelude-annotate-todo ()
      "Put fringe marker on TODO: lines in the curent buffer."
      (interactive)
      (ov-set (format "[[:space:]]*%s+[[:space:]]*TODO:" comment-start)
              'before-string
              (propertize (format "A")
                          'display '(left-fringe right-triangle))
              'modification-hooks '(prelude-todo-ov-evaporate))))
#+END_SRC

*** Rename Mode Line

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))

  (rename-modeline "js2-mode" js2-mode "JS2")
  (rename-modeline "clojure-mode" clojure-mode "Clj")
  (rename-modeline "haskell-mode" haskell-mode "HS")
  (rename-modeline "scala-mode2" scala-mode "SCA")
  (rename-modeline "lisp-mode" emacs-lisp-mode "EL")
  (rename-modeline "lisp-mode" lisp-interaction-mode "EI")
  (rename-modeline "markdown-mode" markdown-mode "MD")
#+END_SRC

* Rock it!

#+begin_src emacs-lisp :tangle yes
  (req-package-finish)
#+end_src
