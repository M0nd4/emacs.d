#+AUTHOR: Jeremy Bi
#+TITLE: My Emacs Configuration

* Emacs Org Configuration

This file is tangled using =org-babel-load-file=. What this does is
generate a =emacs-init.el= from the =emacs-lisp= source blocks.

# This emacs.d is currently designed for [[https://github.com/railwaycat/emacs-mac-port][Emacs Mac Port]].

*** Credits:

This emacs.d was heavily inspired by the following configurations.

[[https://github.com/daschwa/dotfiles/tree/master/emacs.d][Adam Schwartz's emacs.d]]

[[https://github.com/bbatsov/prelude][Bozhidar Batsov's prelude]]

[[https://github.com/larstvei/dot-emacs][larstvei's dot-emacs]]

* Package Management

[[https://github.com/rdallasgray/pallet][Pallet]] is a very helpful package management tool for Emacs.  It
utilizes a dependency management platform called [[https://github.com/cask/cask][Cask]], to update a
centralized =Cask= file when you install or remove packages.

** Cask

Cask is initialized in =init.el= with the following:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

** Pallet

You can download all packages in your =Cask= file by using =M-x
pallet-install=. However, this should not be necessary.
#+BEGIN_SRC emacs-lisp :tangle no
  (require 'pallet)
  (pallet-mode t)
#+END_SRC

* Packages, Modes, and Extensions

** Dependency Management with =use-package=

While Pallet keeps track of the packages we have installed,
=use-package= allows you to isolate package configuration.

Start using =use-package=
#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-when-compile
    (require 'use-package))
  (require 'bind-key)
  (require 'diminish)
#+END_SRC
* Meta

We add a function to the =after-save-hook= ensuring to always tangle
and byte-compile the =org=-document after changes asynchronously.

[[https://github.com/jwiegley/emacs-async][async]] is a module for doing asynchronous processing in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package async
    :ensure
    :config
    (require 'dired-async)
    (defun my/init-hook ()
      "If the current buffer is 'emacs-init.org' the code-blocks
  are tangled, and the tangled file is compiled."
      (when (equal (buffer-file-name) my-org-file)
        (async-start
         `(lambda ()
            (require 'org)
            (org-babel-tangle-file ,my-org-file))
         (lambda (result)
           (message "Tangled file compiled.")))))
    (add-hook 'after-save-hook 'my/init-hook))

  ;; (defun my/compile-init-file ()
  ;;   (interactive)
  ;;   (if (and
  ;;        (string-equal buffer-file-name my-org-file)
  ;;        (file-newer-than-file-p my-init-file (concat my-init-file "c")))
  ;;       (byte-compile-file my-init-file)))

  ;; (add-hook 'kill-buffer-hook 'my/compile-init-file)
#+END_SRC

* Appearance

** Theme

Set custom theme path and load theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package zenburn-theme
    :ensure
    :config
    (load-theme 'zenburn t))

  ;; (use-package solarized-theme
  ;;   :config
  ;;   ;; make the fringe stand out from the background
  ;;   (setq solarized-distinct-fringe-background t)

  ;;   ;; Don't change the font for some headings and titles
  ;;   (setq solarized-use-variable-pitch nil)

  ;;   ;; make the modeline high contrast
  ;;   ;; (setq solarized-high-contrast-mode-line t)

  ;;   ;; Use less bolding
  ;;   (setq solarized-use-less-bold t)

  ;;   ;; Use more italics
  ;;   (setq solarized-use-more-italic t)

  ;;   ;; Use less colors for indicators such as git:gutter, flycheck and similar
  ;;   (setq solarized-emphasize-indicators nil)

  ;;   ;; Don't change size of org-mode headlines (but keep other size-changes)
  ;;   (setq solarized-scale-org-headlines nil)

  ;;   ;; Avoid all font-size changes
  ;;   ;; (setq solarized-height-minus-1 1)
  ;;   ;; (setq solarized-height-plus-1 1)
  ;;   ;; (setq solarized-height-plus-2 1)
  ;;   ;; (setq solarized-height-plus-3 1)
  ;;   ;; (setq solarized-height-plus-4 1)

  ;;   (load-theme 'solarized-dark t))
#+END_SRC

** Mode Line

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smart-mode-line
    :ensure
    :config
    (setq sml/no-confirm-load-theme t)
    ;; (sml/apply-theme 'powerline)
    (sml/setup))
#+END_SRC

* Keybindings

** Improvements
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package elisp
    :load-path "packages/"
    :bind (("M-/" . hippie-expand)
           ("C-x C-b" . ibuffer)
           ([remap goto-line] . goto-line-with-feedback)
           ("C-:" . eval-expression)
           ("M-SPC" . cycle-spacing)
           ("s-k" . kill-this-buffer)
           ("C-c k" . prelude-kill-other-buffers)
           ("C-c n" . prelude-cleanup-buffer-or-region)
           ("C-c d" . duplicate-comment-current-line-or-region)
           ("C-x b" . prelude-switch-to-previous-buffer)
           ("C-^" . prelude-top-join-line)
           ("C-x \\" . align-regexp)
           ("C-S-n" . my/forward-line-by-many)
           ("C-S-p" . my/backward-line-by-many)
           ([remap kill-whole-line] . prelude-kill-whole-line)
           ([(control shift return)] . prelude-smart-open-line-above))
    :bind* (("C-M-h" . backward-kill-word)))

  ;; (bind-key "C-f" 'find-function 'help-command)
  ;; (bind-key "C-k" 'find-function-on-key 'help-command)
  ;; (bind-key "C-v" 'find-variable 'help-command)
  ;; (bind-key "C-l" 'find-library 'help-command)

#+END_SRC

** Key-chord

Key-chord maps pairs of simultaneously pressed keys to commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package key-chord
    :ensure
    :config
    (setq key-chord-two-keys-delay 0.05)
    (key-chord-define-global "x1" 'delete-other-windows)
    ;; (key-chord-define-global "xk" 'ace-window)
    (key-chord-define-global "0o" 'delete-window)
    (key-chord-define-global "xn" 'helm-mini)
    (key-chord-define-global "xb" 'ivy-recentf)
    (key-chord-define-global "jk" 'magit-status)
    (key-chord-define-global "xm" 'helm-M-x)
    ;; (key-chord-define-global "1q" "!")
    ;; (key-chord-define-global "2w" "@")
    ;; (key-chord-define-global "3e" "#")
    ;; (key-chord-define-global "4r" "$")
    ;; (key-chord-define-global "5t" "%")
    ;; (key-chord-define-global "6y" "^")
    ;; (key-chord-define-global "7y" "&")
    ;; (key-chord-define-global "8u" "*")
    ;; (key-chord-define-global "9i" "(")
    ;; (key-chord-define-global "-p" "_")
    (key-chord-mode +1))
#+END_SRC

** Unbind keys

#+BEGIN_SRC emacs-lisp :tangle yes
  (unbind-key "C-o")
  (unbind-key "C-x f")
#+END_SRC

* Essentials

Some quick essential customizations.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Turn off mouse interface early in startup to avoid momentary display
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

  (unless (file-exists-p savefile-dir)
    (make-directory savefile-dir))

  ;; Start off with some sanity.
  (require 'better-defaults)

  ;; OSX specific settings
  (when (eq system-type 'darwin)
    (require 'cocoa-emacs-default))

  ;; Store all backup and autosave files in the tmp dir
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))

  ;; Make backups of files, even when they're in version control
  (setq vc-make-backup-files t)

  ;; saveplace remembers your location in a file when saving files
  (require 'saveplace)
  (setq save-place-file (expand-file-name "saveplace" savefile-dir))
  ;; activate it for all buffers
  (setq-default save-place t)

  ;; savehist keeps track of some history
  (require 'savehist)
  (setq savehist-additional-variables
        ;; search entries
        '(search ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-file (expand-file-name "savehist" savefile-dir))
  (savehist-mode +1)

  ;; reduce the frequency of garbage collection by making it happen on
  (setq gc-cons-threshold (* 1024 1024 20))

  ;; warn when opening files bigger than 100MB
  (setq large-file-warning-threshold 100000000)

  ;; autopair
  ;; (electric-pair-mode)

  ;; enable narrowing commands
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)

  ;; enabled change region case commands
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)

  ;; enable erase-buffer command
  (put 'erase-buffer 'disabled nil)

  (show-paren-mode 1)
#+END_SRC

* Setups

All packages and modes are configured here.
** Major Modes

*** Lisp

**** Clojure

#+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode
    :ensure
    :config
    (defun my/clojure-mode-defaults ()
      (subword-mode +1)
      (smartparens-mode -1))
    (add-hook 'clojure-mode-hook 'my/clojure-mode-defaults))
#+end_src

**** Emacs lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (add-hook 'after-save-hook
              (lambda ()
                (when (file-exists-p (byte-compile-dest-file buffer-file-name))
                  (emacs-lisp-byte-compile)))
              nil
              t))

  (defun my/conditional-emacs-lisp-checker ()
    "Don't check doc style in Emacs Lisp test files."
    (let ((file-name (buffer-file-name)))
      (when (and file-name (string-match-p ".*-tests?\\.el\\'" file-name))
        (setq-local flycheck-checkers '(emacs-lisp)))))

  (defun my/emacs-lisp-mode-defaults ()
    "Sensible defaults for `emacs-lisp-mode'."
    (my/recompile-elc-on-save)
    (smartparens-mode -1)
    (my/conditional-emacs-lisp-checker))

  (add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-mode-defaults)

  ;; ielm is an interactive Emacs Lisp shell
  (defun my/ielm-mode-defaults ()
    "Sensible defaults for `ielm'."
    (whitespace-mode -1))

  (add-hook 'ielm-mode-hook 'my/ielm-mode-defaults)

  (add-to-list 'auto-mode-alist '("Cask\\'" . emacs-lisp-mode))

  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
  (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)

#+END_SRC

*** Geiser/Scheme

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package geiser
  ;;   :config
  ;;   (setq geiser-active-implementations '(racket)))

  (use-package racket-mode
    :ensure
    :config
    (add-hook 'racket-mode-hook
              '(lambda ()
                 (define-key racket-mode-map (kbd "C-c C-l") 'racket-run)
                 (define-key racket-mode-map (kbd "C-c C-k") 'racket-test))))

  (defun my/scheme-mode-defaults ()
    (smartparens-mode -1))

  (add-hook 'scheme-mode-hook #'my/scheme-mode-defaults)
#+END_SRC

*** LaTex

Sane setup for LaTeX writers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auctex-latexmk
    :ensure
    :config
    (auctex-latexmk-setup))
  (use-package cdlatex
    :ensure)

  (use-package tex-site
    :ensure auctex
    :config
    (defun my/latex-mode-defaults ()
      (visual-line-mode +1)
      (yas-minor-mode -1))

    (add-hook 'LaTeX-mode-hook 'my/latex-mode-defaults)
    (add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)
    (add-to-list 'auto-mode-alist '("\\.l[gh]s\\'" . tex-mode))

    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq TeX-save-query nil)

    (setq-default TeX-master nil)

    (setq TeX-PDF-mode t)

    (when (eq system-type 'darwin)
      (setq TeX-view-program-selection
            '((output-dvi "DVI Viewer")
              (output-pdf "PDF Viewer")
              (output-html "HTML Viewer")))

      (setq TeX-view-program-list
            '(("DVI Viewer" "open %o")
              ("PDF Viewer" "open %o")
              ("HTML Viewer" "open %o")))))
#+END_SRC

**** LatexMk

#+begin_src emacs-lisp :tangle no
  (use-package auctex-latexmk
    :ensure
    :config
    (auctex-latexmk-setup))
#+end_src

*** Org Mode

If you are not using it, you need to start.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :defer t
    :config
    (require 'ox-md)
    (require 'ox-latex)

    (defun my/org-mode-defaults ()
      (turn-on-org-cdlatex)
      (diminish 'org-cdlatex-mode "")
      (turn-on-auto-fill))

    (add-hook 'org-mode-hook 'my/org-mode-defaults)

    ;; Fontify org-mode code blocks
    (setq org-src-fontify-natively t)

    (setq org-todo-keyword-faces
          '(("TODO" . (:foreground "green" :weight bold))
            ("NEXT" :foreground "blue" :weight bold)
            ("WAITING" :foreground "orange" :weight bold)
            ("HOLD" :foreground "magenta" :weight bold)
            ("CANCELLED" :foreground "forest green" :weight bold)))

    (setq org-enforce-todo-dependencies t)
    (setq org-src-tab-acts-natively t)

    ;; set up latex
    (setq org-latex-create-formula-image-program 'imagemagick)

    (setq org-latex-pdf-process
          (quote ("pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                  "bibtex $(basename %b)"
                  "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
                  "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f")))

    ;; Tell the latex export to use the minted package for source
    ;; code coloration.
    (add-to-list 'org-latex-packages-alist '("" "minted"))
    (setq org-latex-listings 'minted)

    (setq org-latex-minted-options
          '(("frame" "lines") ("framesep" "6pt")
            ("mathescape" "true") ("fontsize" "\\small")))

    (setq org-confirm-babel-evaluate nil)

    ;; execute external programs.
    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (dot . t)
             (ditaa . t)
             (R . t)
             (python . t)
             (ruby . t)
             (gnuplot . t)
             (clojure . t)
             (sh . t)
             (haskell . t)
             (octave . t)
             (org . t)
             (plantuml . t)
             (scala . t)
             (sql . t)
             (latex . t))))

    (eval-after-load 'org-src
      '(define-key org-src-mode-map
         "\C-x\C-s" #'org-edit-src-exit))

    ;; (org-require 'org-ref)
    ;; (setq org-ref-default-bibliography '("/Users/jeremybi/research/refs.bib")
    ;;       org-ref-pdf-directory "/Users/jeremybi/research/papers/"
    ;;       org-ref-bibliography-notes "/Users/jeremybi/research/notes.org")
    )
#+END_SRC

[[https://github.com/jkitchin/jmax/blob/master/org-ref.org][Org-ref]] is an emacs-lisp module to handle bibliographic citations, and
references to figures, tables and sections in org-mode.

*** Dired

Dired Plus is an extension to the =dired= file manager in Emacs.  My
favorite feature is that pressing =F= will open all marked files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired
    :commands dired-jump
    :config
    (put 'dired-find-alternate-file 'disabled nil)

    ;; always delete and copy recursively
    (setq dired-recursive-deletes 'always)
    (setq dired-recursive-copies 'always)
    ;; show readable size
    (setq dired-listing-switches "-alh")

    (setq dired-dwim-target t)

    ;; enable some really cool extensions like C-x C-j(dired-jump)
    (require 'dired-x)

    (setq-default dired-omit-mode t
                  dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.")
    (use-package dired+ :ensure))


#+END_SRC
*** Scala-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package scala-mode2
    :ensure
    :config
    (setq scala-indent:align-forms t
          scala-indent:align-parameters t)
    (defun my/scala-mode-hook-defaults ()
      (subword-mode +1))
    (add-hook 'scala-mode-hook 'my/scala-mode-hook-defaults))
#+END_SRC

*** OCaml

#+begin_src emacs-lisp :tangle no
  (use-package tuareg
    :config
    (setq auto-mode-alist
          (append '(("\\.ml[ily]?$" . tuareg-mode)
                    ("\\.topml$" . tuareg-mode))
                  auto-mode-alist)))
#+end_src
*** Markdown

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package markdown-mode
    :ensure
    :mode "\\.md\\'")
#+END_SRC

*** C# mode

#+begin_src emacs-lisp :tangle no
  (use-package csharp-mode
    :config
    (bind-key "C-c C-r" 'quickrun csharp-mode-map)
    (quickrun-set-default "c#" "c#/mono"))
#+end_src

*** F2j-mode

#+begin_src emacs-lisp :tangle yes
  (use-package f2j-mode
    :load-path "packages/")
#+end_src

*** Eshell

Type =clear= to clear the buffer like in other terminal emulators.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (setq eshell-directory-name
        (expand-file-name "eshell" savefile-dir))

  (defun eshell/clear ()
    "Clears the shell buffer ala Unix's clear."
    ;; the shell prompts are read-only, so clear that for the duration
    (let ((inhibit-read-only t))
      ;; simply delete the region
      (erase-buffer)))
#+END_SRC

*** Java Mode

#+begin_src emacs-lisp :tangle yes
  (use-package cc-mode
    :config
    (add-hook 'java-mode-hook (lambda ()
                                (setq c-basic-offset 2))))
#+end_src

*** Haskell Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package haskell-mode
    :ensure
    :config
    (defun my/haskell-mode-defaults ()
      (subword-mode +1)
      (turn-on-haskell-doc-mode)
      (turn-on-haskell-indentation)
      ;; (smartparens-mode -1)
      ;; (flycheck-mode -1)
      )

    (add-hook 'haskell-mode-hook 'my/haskell-mode-defaults)
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)

    (require 'haskell)
    (bind-keys :map interactive-haskell-mode-map
               ;; ("M-." . haskell-mode-goto-loc)
               ("M-," . pop-tag-mark)
               ;; ("C-c C-t" . ghc-show-type)
               ;; ("C-M-?" . ghc-display-errors)
               )

    (setq haskell-process-auto-import-loaded-modules t
          haskell-interactive-types-for-show-ambiguous nil
          haskell-process-log t
          haskell-indentation-show-indentations nil)

    ;; (setq haskell-process-args-cabal-repl
    ;;       '("--ghc-option=-ferror-spans" "--with-ghc=ghci-ng"))

    ;; (setq haskell-process-path-ghci "ghci-ng")
    )
#+END_SRC

*** SML Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sml-mode
    :ensure
    :mode "\\.sml\\'"
    :functions sml-prog-proc-send-buffer
    :config
    (defun my-sml-prog-proc-send-buffer ()
      "If sml repl exists, then restart it else create a new repl."
      (interactive)
      (when (get-buffer "*sml*")
        (with-current-buffer "*sml*"
          (when (get-process "sml")
            (comint-send-eof)))
        (sleep-for 0.2)
        (sml-run "sml" ""))
      (sml-prog-proc-send-buffer t))
    (bind-key "C-c C-b" 'my-sml-prog-proc-send-buffer sml-mode-map))

#+END_SRC

*** Idris Mode

#+begin_src emacs-lisp :tangle no
  (use-package idris-mode
    :ensure)
#+end_src

*** Lua Mode

#+begin_src emacs-lisp :tangle yes
  (use-package lua-mode
    :ensure)
#+end_src

*** Js2 Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package js2-mode
    :ensure
    :mode "\\.js\\'")
#+END_SRC

** Minor Modes
*** Recentf

#+begin_src emacs-lisp :tangle yes
  (use-package recentf
    :config
    ;; (setq recentf-exclude
    ;;       '("COMMIT_MSG" "COMMIT_EDITMSG" "github.*txt$"
    ;;         ".*png$"))
    (setq recentf-save-file (expand-file-name "recentf" savefile-dir)
          recentf-max-saved-items 60)
    ;; (recentf-mode +1)
    )
#+end_src

*** Company

[[https://github.com/company-mode/company-mode][Company]] is a code completion framework for Emacs. The name stands for
"complete anything".

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :ensure
    :diminish (company-mode . "CPY")
    :config
    (setq company-tooltip-align-annotations t)
    (setq company-idle-delay 0.3)
    (setq company-dabbrev-ignore-case nil)
    (setq company-dabbrev-downcase nil)
    (eval-after-load 'company-dabbrev-code
      '(dolist (mode '(coq-mode oz-mode))
         (add-to-list 'company-dabbrev-code-modes mode)))
    ;; invert the navigation direction if the the completion popup-isearch-match
    ;; is displayed on top (happens near the bottom of windows)
    (setq company-tooltip-flip-when-above t)
    (setq company-dabbrev-code-other-buffers 'code)
    (global-company-mode))
#+END_SRC
*** Omnisharp-Emacs

Install [[https://github.com/OmniSharp/omnisharp-server][omnisharp-server]] first.

#+begin_src emacs-lisp :tangle no
  (use-package omnisharp
    :config
    (add-to-list 'company-backends 'company-omnisharp)
    (add-hook 'csharp-mode-hook 'omnisharp-mode)
    (setq omnisharp-server-executable-path "/Users/jeremybi/Projects/OmniSharpServer/OmniSharp/bin/Debug/OmniSharp.exe"))
#+end_src

*** Ido-related

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'ido)
  (setq ido-enable-prefix nil
        ido-enable-flex-matching t
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-max-prospects 10
        ido-save-directory-list-file (expand-file-name "ido.hist" savefile-dir)
        ido-default-file-method 'selected-window
        ido-auto-merge-work-directories-length -1)
  (ido-mode +1)

  ;; disable ido faces to see flx highlights
  (setq ido-use-faces nil)
#+END_SRC
*** Magit

[[https://github.com/magit/magit][Magit]] is the ultimate =git= interface for Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure
    :commands magit-status
    :bind ("C-x g" . magit-dispatch-popup))
#+END_SRC

*** hindent

#+begin_src emacs-lisp :tangle yes
  (use-package hindent
    :ensure
    :config
    (setq hindent-style "gibiansky")
    (add-hook 'haskell-mode-hook #'hindent-mode))
#+end_src

*** crosshairs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package crosshairs
    :ensure
    :bind ("C-+" . crosshairs))
#+END_SRC

*** quickrun

#+begin_src emacs-lisp :tangle yes
  (use-package quickrun :ensure)
#+end_src
*** Wgrep

[[https://github.com/mhayashi1120/Emacs-wgrep][Wgrep]] allows you to edit a grep buffer and apply those changes to the
file buffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ag
    :ensure
    :init
    (autoload 'wgrep-ag-setup "wgrep-ag")
    (add-hook 'ag-mode-hook 'wgrep-ag-setup))
#+END_SRC

*** goto-chg

#+begin_src emacs-lisp :tangle yes
  (use-package goto-chg
    :ensure
    :bind ("C-M-." . goto-last-change))
#+end_src

*** gscholar bibtex

#+begin_src emacs-lisp :tangle yes
  (use-package gscholar-bibtex
    :ensure)
#+end_src

*** eyebrowse

#+begin_src emacs-lisp :tangle yes
  (use-package eyebrowse
    :ensure
    :config
    (eyebrowse-mode t))
#+end_src

*** Helm

=helm-mini= is a part of [[https://github.com/emacs-helm/helm][Helm]] that shows current buffers and a list of
recent files using =recentf=.  It is a great way to manage many open
files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm
    :ensure
    :bind (("M-y" . helm-show-kill-ring)
           ("C-x C-f" . helm-find-files)
           ("C-c C-r" . helm-resume))
    :config
    (require 'helm-config)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-quick-update                     t
          helm-split-window-in-side-p           t
          helm-buffers-fuzzy-matching           t
          helm-recentf-fuzzy-match              t
          helm-move-to-line-cycle-in-source     t
          helm-ff-search-library-in-sexp        t
          helm-ff-file-name-history-use-recentf t)

    ;; show minibuffer history with Helm
    (bind-key "C-c C-l" 'helm-minibuffer-history minibuffer-local-map)

    ;; shell history.
    (bind-key "C-c C-l" 'helm-comint-input-ring shell-mode-map)

    (helm-mode +1))
#+END_SRC
*** zop-to-char

#+begin_src emacs-lisp :tangle yes
  (use-package zop-to-char
    :ensure
    :bind ("M-z" . zop-to-char))
#+end_src

*** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] make Emacs bindings that stick around.

#+begin_src emacs-lisp :tangle yes
  (use-package hydra
    :ensure
    :config
    (hydra-add-font-lock)
    (global-set-key
     (kbd "C-x t")
     (defhydra hydra-toggle (:color teal)
       "
  _a_ abbrev-mode:      %`abbrev-mode
  _d_ debug-on-error    %`debug-on-error
  _f_ auto-fill-mode    %`auto-fill-function
  _t_ truncate-lines    %`truncate-lines

  "
       ("a" abbrev-mode nil)
       ("d" toggle-debug-on-error nil)
       ("f" auto-fill-mode nil)
       ("t" toggle-truncate-lines nil)
       ("q" nil "cancel")))

    (key-chord-define-global
     "ds"
     (defhydra hydra-zoom ()
       "zoom"
       ("j" text-scale-increase "in")
       ("k" text-scale-decrease "out")
       ("0" (text-scale-set 0) "reset")
       ("1" (text-scale-set 0) :bind nil)
       ("2" (text-scale-set 0) :bind nil :color blue)))

    (defhydra hydra-error (global-map "M-g")
      "goto-error"
      ("h" flycheck-list-errors "first")
      ("j" flycheck-next-error "next")
      ("k" flycheck-previous-error "prev")
      ("v" recenter-top-bottom "recenter")
      ("q" nil "quit"))

    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window (:color amaranth)
       "
  Move Point^^^^   Move Splitter   ^Ace^                       ^Split^
  --------------------------------------------------------------------------------
  _w_, _<up>_      Shift + Move    _C-a_: ace-window           _2_: split-window-below
  _a_, _<left>_                    _C-s_: ace-window-swap      _3_: split-window-right
  _s_, _<down>_                    _C-d_: ace-window-delete    ^ ^
  _d_, _<right>_                   ^   ^                       ^ ^
  You can use arrow-keys or WASD.
  "
       ("2" split-window-below nil)
       ("3" split-window-right nil)
       ("a" windmove-left nil)
       ("s" windmove-down nil)
       ("w" windmove-up nil)
       ("d" windmove-right nil)
       ("A" hydra-move-splitter-left nil)
       ("S" hydra-move-splitter-down nil)
       ("W" hydra-move-splitter-up nil)
       ("D" hydra-move-splitter-right nil)
       ("<left>" windmove-left nil)
       ("<down>" windmove-down nil)
       ("<up>" windmove-up nil)
       ("<right>" windmove-right nil)
       ("<S-left>" hydra-move-splitter-left nil)
       ("<S-down>" hydra-move-splitter-down nil)
       ("<S-up>" hydra-move-splitter-up nil)
       ("<S-right>" hydra-move-splitter-right nil)
       ("C-a" ace-window nil)
       ("u" hydra--universal-argument nil)
       ("C-s" (lambda () (interactive) (ace-window 4)) nil)
       ("C-d" (lambda () (interactive) (ace-window 16)) nil)
       ("q" nil "quit")))

    (defhydra hydra-org-template (:color blue :hint nil)
      "
  _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
  _l_atex   _E_xample   _p_erl          _i_ndex:
  _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
  _s_rc     ^ ^         plant_u_ml      _H_TML:
  _h_tml    ^ ^         ^ ^             _A_SCII:
  "
      ("s" (hot-expand "<s"))
      ("E" (hot-expand "<e"))
      ("q" (hot-expand "<q"))
      ("v" (hot-expand "<v"))
      ("c" (hot-expand "<c"))
      ("l" (hot-expand "<l"))
      ("h" (hot-expand "<h"))
      ("a" (hot-expand "<a"))
      ("L" (hot-expand "<L"))
      ("i" (hot-expand "<i"))
      ("e" (progn
             (hot-expand "<s")
             (insert "emacs-lisp")
             (forward-line)))
      ("p" (progn
             (hot-expand "<s")
             (insert "perl")
             (forward-line)))
      ("u" (progn
             (hot-expand "<s")
             (insert "plantuml :file CHANGE.png")
             (forward-line)))
      ("P" (progn
             (insert "#+HEADERS: :results output :exports both :shebang \"#!/usr/bin/env perl\"\n")
             (hot-expand "<s")
             (insert "perl")
             (forward-line)))
      ("I" (hot-expand "<I"))
      ("H" (hot-expand "<H"))
      ("A" (hot-expand "<A"))
      ("<" self-insert-command "ins")
      ("o" nil "quit"))

    (defun hot-expand (str)
      "Expand org template."
      (insert str)
      (org-try-structure-completion))

    (with-eval-after-load "org"
      (define-key org-mode-map "<"
        (lambda () (interactive)
          (if (looking-back "^")
              (hydra-org-template/body)
            (self-insert-command 1))))))

  (global-set-key
   (kbd "s-p")
   (defhydra hydra-projectile (:color blue :columns 4)
     "Projectile"
     ("a" helm-projectile-ag "ag")
     ("b" projectile-switch-to-buffer "switch to buffer")
     ("c" projectile-invalidate-cache "cache clear")
     ("d" projectile-find-dir "dir")
     ("s-f" projectile-find-file "file")
     ("ff" projectile-find-file-dwim "file dwim")
     ("fd" projectile-find-file-in-directory "file curr dir")
     ("g" ggtags-update-tags "update gtags")
     ("i" projectile-ibuffer "Ibuffer")
     ("K" projectile-kill-buffers "Kill all buffers")
     ("o" projectile-multi-occur "multi-occur")
     ("p" projectile-switch-project "switch")
     ("r" projectile-run-async-shell-command-in-root "run shell command")
     ("x" projectile-remove-known-project "remove known")
     ("X" projectile-cleanup-known-projects "cleanup non-existing")
     ("z" projectile-cache-current-file "cache current")
     ("q" nil "cancel")))
#+end_src

*** Pandoc-mode

#+begin_src emacs-lisp :tangle yes
  (use-package pandoc-mode
    :ensure
    :config
    (add-hook 'markdown-mode-hook 'pandoc-mode)
    (add-hook 'org-mode-hook 'pandoc-mode)
    (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings))
#+end_src
*** Elpy

#+begin_src emacs-lisp :tangle yes
  (use-package elpy
    :ensure
    :config
    (remove-hook 'elpy-modules 'elpy-module-flymake)
    (remove-hook 'elpy-modules 'elpy-module-yasnippet)
    (diminish 'elpy-mode "☕")
    (elpy-enable)
    ;; (elpy-use-ipython)
    )
#+end_src
*** Chinese-font-setup

#+begin_src emacs-lisp :tangle yes
  (use-package chinese-fonts-setup
    :ensure)
#+end_src

*** mwim

Move to the beginning/end of line or code

#+begin_src emacs-lisp :tangle yes
  (use-package mwim
    :ensure
    :bind ("C-a" . mwim-beginning-of-code-or-line))
#+end_src
*** Helm-descbinds

[[https://github.com/emacs-helm/helm-descbinds][Helm Descbinds]] provides an interface to emacs' =describe-bindings=
making the currently active key bindings interactively searchable
with helm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-descbinds
    :ensure
    :bind ("C-c b" . helm-descbinds))
#+END_SRC

*** Fullframe

[[https://github.com/tomterl/fullframe][Fullframe]] advises commands to execute fullscreen, restoring the window
setup when exiting.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fullframe
    :ensure
    :config
    (fullframe magit-status magit-mode-quit-window)
    (fullframe ibuffer ibuffer-quit))
#+END_SRC

*** Exec-path-from-shell

A GNU Emacs library to setup environment variables from the user's
shell.

#+begin_src emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :ensure
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))
#+end_src

*** Agda

#+begin_src emacs-lisp :tangle yes
  (if (executable-find "agda-mode")
      (load-file (let ((coding-system-for-read 'utf-8))
                   (shell-command-to-string "agda-mode locate"))))
#+end_src

*** Ace-window

[[https://github.com/abo-abo/ace-window][Ace-window]] provides window switching, the visual way.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
    :ensure
    :bind ("s-w" . ace-window)
    :config
    ;; (setq aw-leading-char-style 'path)
    (setq aw-background nil)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-scope 'frame)
    ;; (ace-window-display-mode +1)
    )
#+END_SRC

*** avy

#+begin_src emacs-lisp :tangle yes
  (use-package avy
    :ensure
    :bind ("s-l" . avy-goto-line)
    :config
    (setq avy-background t)
    (setq avy-styles-alist '((avy-goto-word-or-subword-1 . de-brujin)))
    (bind-key* "s-." 'avy-goto-word-or-subword-1))
#+end_src

*** Swiper

#+begin_src emacs-lisp :tangle yes
  (use-package swiper
    :ensure
    :bind (("C-r" . swiper)
           ("C-s" . swiper)
           ;; ("C-c C-r" . ivy-resume)
           )
    :config
    ;; (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-format-function 'ivy-format-function-arrow))
#+end_src

*** Counsel

#+begin_src emacs-lisp :tangle no
  (use-package counsel
    :ensure
    :bind (("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("C-x C-f" . counsel-find-file)
           ;; ("C-c j" . counsel-git-grep)
           ("M-x" . counsel-M-x))
    :config
    (setq counsel-find-file-at-point t)
    (ivy-set-actions
     'counsel-find-file
     `((,(propertize "delete" 'face 'font-lock-warning-face)
        (lambda (x) (delete-file (expand-file-name x ivy--directory))))))
    (use-package smex :ensure))
#+end_src

*** Rainbow mode

=rainbow-mode= displays hexadecimal colors with the color they
represent as their background.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :ensure
    :diminish (rainbow-mode . "")
    :config
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

*** Rainbow-delimiter

[[https://github.com/jlr/rainbow-delimiters][Rainbow Delimiters]] is a “rainbow parentheses”-like mode which
highlights parentheses, brackets, and braces according to their depth

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rainbow-delimiters
    :ensure
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** Operate-on-numbes

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package operate-on-number
    :config
    (require 'smartrep)
    (setq smartrep-mode-line-active-bg nil)
    (smartrep-define-key global-map "C-c ."
      '(("+" . apply-operation-to-number-at-point)
        ("-" . apply-operation-to-number-at-point)
        ("*" . apply-operation-to-number-at-point)
        ("/" . apply-operation-to-number-at-point)
        ("^" . apply-operation-to-number-at-point)
        ("<" . apply-operation-to-number-at-point)
        (">" . apply-operation-to-number-at-point)
        ("'" . operate-on-number-at-point))))
#+END_SRC

*** Expand-region

[[https://github.com/magnars/expand-region.el][Expand-region]] increases the selected region by semantic units. Just
keep pressing the key until it selects what you want.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :ensure
    :bind ("M-2" . er/expand-region))
#+END_SRC

*** Whitespace

Whitespace-mode configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package whitespace
    :diminish (whitespace-mode . "")
    :config
    ;; (setq whitespace-line-column 80)
    (setq whitespace-style '(face tabs trailing))

    (defun prelude-enable-whitespace ()
      "Enable `whitespace-mode' if `prelude-whitespace' is not nil."
      ;; (add-hook 'before-save-hook 'whitespace-cleanup nil t)
      (whitespace-mode +1))

    (add-hook 'text-mode-hook 'prelude-enable-whitespace)
    (add-hook 'prog-mode-hook 'prelude-enable-whitespace))

#+END_SRC

*** Whitespace-cleanup-mode

#+begin_src emacs-lisp :tangle yes
  (use-package whitespace-cleanup-mode
    :ensure
    :diminish (whitespace-cleanup-mode . "")
    :config
    (add-hook 'prog-mode-hook 'whitespace-cleanup-mode))
#+end_src

*** Projectile

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :ensure
    :diminish ""
    :config
    (setq projectile-cache-file
          (expand-file-name  "projectile.cache" savefile-dir)
          projectile-completion-system 'helm
          projectile-sort-order 'modification-time)
    (projectile-global-mode t))
#+END_SRC

*** Helm-projectile

#+begin_src emacs-lisp :tangle yes
  (use-package helm-projectile
    :ensure)
#+end_src

*** Helm-ag

#+begin_src emacs-lisp :tangle yes
  (use-package helm-ag
    :ensure
    :config
    (setq helm-ag-base-command "ag --nocolor --nogroup --ignore-case"
          helm-ag-command-option "--all-text"
          helm-ag-insert-at-point 'symbol))
#+end_src

*** Lispy

[[https://github.com/abo-abo/lispy][Lispy]] implements various vi-like commands for navigating and editing
Lisp code.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lispy
    :ensure
    :defer 2
    :init
    (dolist (hook '(emacs-lisp-mode-hook
                    lisp-mode-hook
                    scheme-mode-hook
                    clojure-mode-hook))
      (add-hook hook (lambda () (lispy-mode +1))))
    :config
    (bind-keys :map lispy-mode-map
               ("C-e" . nil)
               ("/" . nil)
               ("M-i" . nil)
               ("M-e" . lispy-iedit)
               ("S" . special-lispy-splice)
               ("g" . special-lispy-goto-local)
               ("G" . special-lispy-goto)))
#+END_SRC

*** Yasnippets

Snippets are keys.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure
    :diminish (yas-minor-mode . "")
    :config
    (add-to-list 'auto-mode-alist '("\\.yasnippet$" . snippet-mode))
    (setq yas-verbosity 1)
    (setq yas-wrap-around-region t)
    (setq-default yas-prompt-functions '(yas-ido-prompt))
    (bind-key "<return>" 'yas-exit-all-snippets yas-keymap)
    (yas-global-mode 1))
#+END_SRC

*** Undo-Tree

More natural undo or redo. Undo with =C-/= and redo with =C-?=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :ensure
    :diminish (undo-tree-mode . "")
    :config
    (global-undo-tree-mode 1))
#+END_SRC

*** Cider

#+begin_src emacs-lisp :tangle no
  (use-package cider
    :ensure
    :defer 3
    :config
    (setq nrepl-log-messages t)
    (setq nrepl-hide-special-buffers t)
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-repl-result-prefix ";; => ")
    (setq cider-interactive-eval-result-prefix ";; => ")
    ;; (add-hook 'cider-mode-hook 'eldoc-mode)
    (defun my/cider-repl-mode-defaults ()
      (subword-mode +1)
      (smartparens-strict-mode +1))
    (add-hook 'cider-repl-mode-hook 'my/cider-repl-mode-defaults))
#+end_src

*** Merlin and utop

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package utop
    :ensure
    :config
    ;; Automatically load utop.el
    (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)
    (add-hook 'tuareg-mode-hook 'utop-minor-mode))

  (use-package merlin
    :ensure
    :config
    (add-hook 'tuareg-mode-hook 'merlin-mode)
    (setq merlin-error-after-save nil)
    ; Make company aware of merlin
    (add-to-list 'company-backends 'merlin-company-backend))
#+END_SRC
*** Company-ghc

#+begin_src emacs-lisp :tangle no
  (use-package company-ghc
    :ensure
    :config
    (add-to-list 'company-backends '(company-ghc :with company-dabbrev-code)))
#+end_src
*** Company-ghci

#+begin_src emacs-lisp :tangle yes
  (use-package company-ghci
    :ensure
    :config
    (add-to-list 'company-backends 'company-ghci)
    (add-hook 'haskell-interactive-mode-hook 'company-mode))
#+end_src
*** Company-math

#+begin_src emacs-lisp :tangle yes
  (use-package company-math
    :ensure
    :config
    ;; global activation of the unicode symbol completion
    (add-to-list 'company-backends 'company-math-symbols-unicode)
    ;; local configuration for TeX modes
    (defun my/latex-mode-setup ()
      (setq-local company-backends
                  (append '(company-math-symbols-latex company-latex-commands)
                          company-backends)))

    (add-hook 'TeX-mode-hook 'my/latex-mode-setup))
#+end_src

*** Company-coq

#+begin_src emacs-lisp :tangle yes
  (use-package company-coq
    :ensure
    :config
    ;; Load company-coq when opening Coq files
    (setq company-coq-prettify-symbols nil)
    (add-hook 'coq-mode-hook #'company-coq-initialize))
#+end_src

*** Flyspell

Enable spell-checking in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :ensure
    :diminish (flyspell-mode . "")
    :init
    ;; Enable spell check in only plaintext
    (add-hook 'text-mode-hook 'flyspell-mode)
    ;; Enable spell check in comments
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    :config
    (setq flyspell-issue-welcome-flag nil)
    (setq flyspell-issue-message-flag nil)
    (setq ispell-program-name "aspell"    ; use aspell instead of ispell
          ispell-extra-args '("--sug-mode=ultra"))
    ;; Make spell check on right click.
    (define-key flyspell-mouse-map [down-mouse-3] 'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] 'undefined)
    (define-key flyspell-mode-map (kbd "C-M-i") nil)
    (define-key flyspell-mode-map (kbd "C-;") nil))

#+END_SRC

**** Helpful Default Keybindings
=C-.= corrects word at point.  =C-,​= to jump to next misspelled word.
*** Browse-kill-ring

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package browse-kill-ring
    :config
    (browse-kill-ring-default-keybindings))
#+END_SRC

*** Flycheck

A great syntax checker.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :ensure
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (setq flycheck-indication-mode nil))
#+END_SRC

*** Flycheck-haskell

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck-haskell
    :ensure
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
#+end_src

*** Pop Win

[[https://github.com/m2ym/popwin-el][popwin]] is used to manage the size of "popup" buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package popwin
    :ensure
    :config
    (popwin-mode 1))
#+END_SRC

*** Multiple Cursors

[[https://github.com/emacsmirror/multiple-cursors][Multiple Cursors]] brings you seemingly unlimited power.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :ensure
    :bind (("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ("C-c C->" . mc/mark-more-like-this-extended))
    :init
    (setq mc/list-file (expand-file-name "mc-lists.el" savefile-dir)))
#+END_SRC

*** Move-text

Move lines or a region up or down.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package move-text
    :ensure
    :bind (("<C-M-up>" . move-text-up)
           ("<C-M-down>" . move-text-down)))
#+END_SRC

*** Reveal-in-finder

Open file in Finder

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package reveal-in-finder
    :ensure
    :if (eq system-type 'darwin)
    :bind
    ("C-c o" . reveal-in-finder))
#+END_SRC

*** Sbt-mode

[[https://github.com/hvesalai/sbt-mode][Sbt-mode]] is an emacs mode for interacting with sbt, scala console
(aka REPL) and sbt projects.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sbt-mode
    :ensure
    :config
    (add-hook 'scala-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-x '") 'sbt-run-previous-command)))
    (add-hook 'sbt-mode-hook
              '(lambda ()
                 (setq compilation-skip-threshold 1)
                 (local-set-key (kbd "C-a") 'comint-bol)
                 (local-set-key (kbd "M-RET") 'comint-accumulate))))
#+END_SRC

*** Ensime

[[https://github.com/ensime/ensime-src][ENSIME]] is the ENhanced Scala Interaction Mode for Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ensime
    :defer 2
    :ensure
    :config
    (add-hook 'scala-mode-hook 'ensime-scala-mode-hook))
#+END_SRC

*** Ebib

[[https://github.com/joostkremers/ebib][Ebib]] is a BibTeX database manager that runs in GNU Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ebib
    :ensure)
#+END_SRC

*** Lexbind-mode

[[https://github.com/spacebat/lexbind-mode][Lexbind-mode]] is an Emacs minor mode to display the value of the
lexical-binding variable which determines the behaviour of
variable binding forms in Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lexbind-mode
    :ensure
    :init
    (setq initial-buffer-choice 'lexbind-lexscratch)
    :config
    (add-hook 'emacs-lisp-mode-hook 'lexbind-mode))
#+END_SRC

*** Smartparens

Show matching and unmatched delimiters, and auto-close them as well.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens-config
    :ensure smartparens
    :config
    ;; highlights matching pairs
    (setq sp-base-key-bindings 'paredit)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-hybrid-kill-entire-symbol nil)
    (sp-use-paredit-bindings)
    (sp-pair "{" nil :post-handlers
             '(((lambda (&rest _ignored)
                  (prelude-smart-open-line-above)) "RET")))
    (smartparens-global-mode +1))
#+END_SRC

*** GHC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ghc
    :ensure
    :config
    (autoload 'ghc-init "ghc" nil t)
    (autoload 'ghc-debug "ghc" nil t)
    (setq ghc-ghc-options '("-fno-warn-unused-do-bind"))
    (add-hook 'haskell-mode-hook (lambda () (ghc-init))))
#+END_SRC

*** Structured-haskell-mode

[[https://github.com/chrisdone/structured-haskell-mode][Structured-haskell-mode]] is a minor mode providing structured editing
operations based on the syntax of Haskell.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package shm
    :config
    (add-hook 'haskell-mode-hook 'structured-haskell-mode)
    (define-key shm-map (kbd "M-s") nil)
    (define-key shm-map (kbd "M-S") 'shm/splice)
    (require 'shm-reformat)
    (setq hindent-style "chris-done")
    (bind-key "C-c i" 'shm-reformat-decl haskell-mode-map))
#+END_SRC

*** Ace-link

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-link
    :config
    (ace-link-setup-default))
#+END_SRC

*** Easy-kill

[[https://github.com/leoliu/easy-kill][easy-kill]] provides commands to let users kill or mark things easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package easy-kill
    :ensure
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill))
#+END_SRC

*** Dash-at-point

[[Dash][http://kapeli.com/]] is an API Documentation Browser and Code Snippet
Manager. [[https://github.com/stanaka/dash-at-point][dash-at-point]] make it easy to search the word at point with
Dash.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dash-at-point
    :ensure
    :if (eq system-type 'darwin))
#+END_SRC

*** Visual-regexp-steroids

[[https://github.com/benma/visual-regexp-steroids.el/][visual-regexp-steroids]] enables the use of modern regexp engines (no
more escaped group parentheses, and other goodies!).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package visual-regexp
    :ensure
    :defines regexp-string replace-string
    :bind (("C-c r" . vr/replace)
           ("C-c q" . vr/query-replace))
    :config
    (use-package visual-regexp-steroids
      :ensure))
#+END_SRC

*** Worf Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package worf
    :ensure
    :defer 2
    :init
    (add-hook 'org-mode-hook 'worf-mode))
#+END_SRC

*** Skeletor

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package skeletor
    :ensure
    :config
    (setq skeletor-scala-use-ensime t))
#+END_SRC

*** ggtags

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ggtags
    :ensure
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                  (ggtags-mode 1)
                  (setq-local eldoc-documentation-function #'ggtags-eldoc-function)))))
#+END_SRC

*** VLFI

View Large Files in Emacs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package vlf-setup
    :ensure vlf
    :config
    (setq vlf-batch-size 10240)
    (setq vlf-application 'dont-ask))
#+END_SRC
*** Anzu Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package anzu
    :ensure
    :bind (("M-%" . anzu-query-replace)
           ("C-M-%" . anzu-query-replace-regexp))
    :diminish (anzu-mode . "")
    :init
    (global-anzu-mode +1))
#+END_SRC

*** Volatile-highlights

#+begin_src emacs-lisp :tangle no
  (use-package volatile-highlights
    :diminish (volatile-highlights-mode . "")
    :config
    (volatile-highlights-mode t))
#+end_src

*** Multi-term

Consult [[http://rawsyntax.com/blog/learn-emacs-zsh-and-multi-term/][Zsh and Multi-term]] for setup probelm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multi-term
    :ensure
    :bind (("C-c t" . multi-term)
           ("C-c \"" . multi-term-dedicated-toggle))
    :config
    (setq multi-term-program (getenv "SHELL")
          multi-term-buffer-name "term"
          multi-term-dedicated-select-after-open-p t)
    (add-hook 'term-mode-hook
              (lambda ()
                (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
                (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))
                ;; conflict with yasnippet
                (yas-minor-mode -1)
                (company-mode -1))))
#+END_SRC

*** Git-timemachine

#+begin_src emacs-lisp :tangle yes
  (use-package git-timemachine
    :ensure)
#+end_src

*** Fix-word

#+begin_src emacs-lisp :tangle yes
  (use-package fix-word
    :ensure
    :bind (("M-u" . fix-word-upcase)
           ("M-l" . fix-word-downcase)
           ("M-c" . fix-word-capitalize)))
#+end_src

** Buffer
*** Toggle Windows

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun toggle-window-split ()
    "Toggle window splitting between horizontal to vertical."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+END_SRC

*** Indent and untabfy Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro with-region-or-buffer (func)
    "When called with no active region, call FUNC on current buffer."
    `(defadvice ,func (before with-region-or-buffer activate compile)
       (interactive
        (if mark-active
            (list (region-beginning) (region-end))
          (list (point-min) (point-max))))))

  (with-region-or-buffer indent-region)
  (with-region-or-buffer untabify)
#+END_SRC

** Miscellaneous
*** Search

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-search (query-url prompt)
    "Open the search url constructed with the QUERY-URL.
  PROMPT sets the `read-string prompt."
    (browse-url
     (concat query-url
             (url-hexify-string
              (if mark-active
                  (buffer-substring (region-beginning) (region-end))
                (read-string prompt))))))

  (defmacro prelude-install-search-engine (search-engine-name search-engine-url search-engine-prompt)
    "Given some information regarding a search engine, install the
  interactive command to search through them"
    `(defun ,(intern (format "prelude-%s" search-engine-name)) ()
       ,(format "Search %s with a query or region if any." search-engine-name)
       (interactive)
       (prelude-search ,search-engine-url ,search-engine-prompt)))

  (prelude-install-search-engine "google" "http://www.google.com/search?q=" "Google: ")
  (prelude-install-search-engine "github" "https://github.com/search?q=" "Search GitHub: ")
#+END_SRC
*** Colorize compilation buffers

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Compilation from Emacs
  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag,
    ;; etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (require 'compile)
  (setq compilation-ask-about-save nil  ; Just save before compiling
        compilation-always-kill t       ; Just kill old compile processes before
                                          ; starting the new one
        compilation-scroll-output 'first-error ; Automatically scroll to first
                                          ; error
        )

  ;; Colorize output of Compilation Mode, see
  ;; http://stackoverflow.com/a/3072831/355252
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook #'prelude-colorize-compilation-buffer)
#+END_SRC

*** Annotate TODOs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ov
    :config
    (defun prelude-todo-ov-evaporate (_ov _after _beg _end &optional _length)
      (let ((inhibit-modification-hooks t))
        (if _after (ov-reset _ov))))
    (defun prelude-annotate-todo ()
      "Put fringe marker on TODO: lines in the curent buffer."
      (interactive)
      (ov-set (format "[[:space:]]*%s+[[:space:]]*TODO:" comment-start)
              'before-string
              (propertize (format "A")
                          'display '(left-fringe right-triangle))
              'modification-hooks '(prelude-todo-ov-evaporate))))
#+END_SRC

*** Rename Mode Line

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))

  (rename-modeline "js2-mode" js2-mode "JS2")
  (rename-modeline "clojure-mode" clojure-mode "Clj")
  (rename-modeline "haskell-mode" haskell-mode "HS")
  (rename-modeline "scala-mode2" scala-mode "SCA")
  (rename-modeline "lisp-mode" emacs-lisp-mode "EL")
  (rename-modeline "lisp-mode" lisp-interaction-mode "EI")
#+END_SRC

